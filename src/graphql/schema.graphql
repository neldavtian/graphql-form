
type Query {
  # Получить язык по ID
  language(id: ID): Languages

  # Получить лимит по ID
  accountLimit(id: ID): AccountLimit

  # Получить лимит по ID
  accountReachedLimit(id: ID): AccountReachedLimit

  # Получить выписку по счету
  accountStatement(account_id: ID!, created_at: DateTimeRange): AccountStatement

  # Получить выписку по счету в формате PDF
  downloadAccountStatementPdf(
    account_id: ID!
    created_at: DateTimeRange
  ): RawFile

  # Получить выписку по счету в формате XLS
  downloadAccountStatementXls(
    account_id: ID!
    created_at: DateTimeRange
  ): RawFile

  # Получить выписку по счету в формате CSV
  downloadAccountStatementCsv(
    account_id: ID!
    created_at: DateTimeRange
  ): RawFile

  # Получить аккаунт по ID
  account(id: ID!): Account

  # Получить список account states
  accountStates(
    orderBy: [QueryAccountStatesOrderByOrderByClause!]
  ): [AccountState!]!

  # Получить список клиентов
  clientList(group_type: ID): [AccountClient!]!

  # Получить список сессий
  # query: {column: COMPANY, value: "", column: PROVIDER, value: "", column: GROUP, value: "", column: CREATED_AT, value: "2021-10-12"} фильтр по company, member, group, created_at
  activeSessions(
    page: Int = 1
    count: Int = 15
    query: QueryActiveSessionsStatic
  ): ActiveSessions

  # Получить список логов активности
  # query: {
  #     column: COMPANY, value: "",
  #     column: MEMBER, value: "",
  #     column: GROUP, value: "",
  #     column: DOMAIN, value: "",
  #     column: CREATED_AT, value: "2021-10-12"
  # } фильтр по company, member, group, domain, created_at
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по created_at
  activityLogs(
    page: Int = 1
    count: Int = 15
    query: QueryActivityLogsStatic
    orderBy: [OrderBy!]
  ): ActivityLogs

  # Получить пользователя  по ID
  applicantIndividual(id: ID): ApplicantIndividual

  # Вывод списка овнеров для компаний
  owners(orderBy: [QueryOwnersOrderByOrderByClause!]): [ApplicantIndividual!]!
  applicantBankingAccess(id: ID): ApplicantBankingAccess
  grantedBankingAccess(
    applicant_individual_id: ID!
    applicant_company_id: ID!
    page: Int = 1
    first: Int = 15
    filter: QueryGrantedBankingAccessFilterFilterConditions
    orderBy: [QueryGrantedBankingAccessOrderByOrderByClause!]
  ): ApplicantBankingAccesses

  # Получить список пользователей
  # orderBy: [{ column: APPLICANT_INDIVIDUAL_ID, order: DESC }] сортировка по ID, по имени, фамилии, email
  # filter: {column: MEMBER_ID, operator: EQ, value: 2} фильтр по member_id, grant_access
  applicantBankingAccesses(
    applicant_company_id: ID!
    page: Int = 1
    first: Int = 15
    filter: QueryApplicantBankingAccessesFilterFilterConditions
    orderBy: [QueryApplicantBankingAccessesOrderByOrderByClause!]
  ): ApplicantBankingAccesses

  # Получить пользователя  по ID
  applicantCompany(id: ID): ApplicantCompany

  # Получить список всех привязаных applicant (individual/company) по applicant_company_id
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_company_id, operator: LIKE, value: ""} фильтр по applicant_company_id
  getMatchedUsers(
    applicant_company_id: ID!
    filter: QueryGetMatchedUsersFilterFilterConditions
  ): [ApplicantIndividualCompany!]!

  # Получить список ApplicantIndividualCompany по applicant_company_id, где type = ApplicantIndividual
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  getMatchedApplicantIndividuals(
    applicant_company_id: ID!
  ): [ApplicantIndividualCompany!]!

  # Получить метку по ID
  applicantCompanyLabel(id: ID): ApplicantCompanyLabel

  # Получить все метки
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantCompanyLabels(
    company_id: ID
    where: QueryApplicantCompanyLabelsWhereWhereConditions
    orderBy: [QueryApplicantCompanyLabelsOrderByOrderByClause!]
  ): [ApplicantCompanyLabel!]!

  # Получить список всех модулей компании
  applicantCompanyModules(
    applicant_company_id: ID!
  ): [ApplicantCompanyModules!]!

  # Получить заметку  по ID
  applicantCompanyNote(id: ID): ApplicantCompanyNotes

  # Получить документ
  applicantDocument(id: ID!): ApplicantDocument

  # Получить должность по ID
  applicantIndividualCompanyPosition(id: ID): ApplicantIndividualCompanyPosition

  # Получить по ID
  applicantIndividualCompanyRelation(id: ID): ApplicantIndividualCompanyRelation

  # Получить список всех модулей аппликанта
  applicantIndividualModules(
    applicant_individual_id: ID!
  ): [ApplicantIndividualModules!]!

  # Получить уровень KYC по  ID
  applicantKycLevel(id: ID): ApplicantKycLevel

  # Получить метку по ID
  applicantIndividualLabel(id: ID): ApplicantIndividualLabel

  # Получить все метки
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualLabels(
    applicant_id: ID
    where: QueryApplicantIndividualLabelsWhereWhereConditions
    orderBy: [QueryApplicantIndividualLabelsOrderByOrderByClause!]
  ): [ApplicantIndividualLabel!]!

  # Вывод списка связанные компании
  applicantLinkedCompanies(
    applicant_individual_id: ID!
  ): [ApplicantLinkedCompany!]!

  # Получить модуль по ID
  applicant_module(id: ID): ApplicantModules

  # Получить заметку  по ID
  applicantIndividualNote(id: ID): ApplicantIndividualNotes

  # Получить уровень риска по  ID
  applicantRiskLevel(id: ID): ApplicantRiskLevel

  # Получить состояние по ID
  applicantState(id: ID): ApplicantState

  # Получить причину по ID
  applicantStateReason(id: ID): ApplicantStateReason

  # Получить статутс по ID
  applicantStatus(id: ID): ApplicantStatus

  # Получить список
  applicantVerificationStatuses: [ApplicantVerificationStatus!]!

  # Получить список логов аутентификации
  # query: {
  #     column: COMPANY, value: "",
  #     column: MEMBER, value: "",
  #     column: CLIENT_TYPE, value: "",
  #     column: GROUP, value: "",
  #     column: DOMAIN, value: "",
  #     column: IP, value: "",
  #     column: COUNTRY, value: "",
  #     column: CITY, value: "",
  #     column: PLATFORM, value: "",
  #     column: BROWSER, value: "",
  #     column: DEVICE_TYPE, value: "",
  #     column: MODEL, value: "",
  #     column: STATUS, value: "",
  #     column: EXPIRED_AT, value: "2021-10-12",
  #     column: CREATED_AT, value: "2021-10-12"
  # } фильтр по company, member, group, domain, ip, country, city, platform, browser, device_type, model, status, expired_at, created_at
  # orderBy: [{ column: EXPIRED_AT, order: DESC }] сортировка по expired_at, created_at, id
  authenticationLogs(
    page: Int = 1
    first: Int = 10
    query: QueryAuthenticationLogsStatic
    orderBy: [OrderBy!]
  ): AuthenticationLogs

  # Получить список логов для мембера по его ID
  authenticationMemberLogs(
    member_id: ID!
    page: Int = 1
    first: Int = 10
    orderBy: [OrderBy!]
  ): AuthenticationLogs

  # Получить запись
  bankCorrespondent(id: ID!): BankCorrespondent!

  # Получить по ID
  businessActivity(id: ID): BusinessActivity

  # Получить прайс по ID
  commissionPriceList(id: ID): CommissionPriceList

  # Получить шаблон по ID
  commissionTemplate(id: ID): CommissionTemplate

  # Получить лимит по ID
  commissionTemplateLimit(id: ID): CommissionTemplateLimit

  # Получить по ID
  commissionTemplateLimitActionType(id: ID): CommissionTemplateLimitActionType

  # Получить по ID
  commissionTemplateLimitPeriod(id: ID): CommissionTemplateLimitPeriod

  # Получить по ID
  commissionTemplateLimitTransferDirection(
    id: ID
  ): CommissionTemplateLimitTransferDirection

  # Получить по ID
  commissionTemplateLimitType(id: ID): CommissionTemplateLimitType

  # Получить компанию по ID
  company(id: ID): Company

  # Получить список модулей
  companyModules(company_id: ID!): [CompanyModule!]!

  # Получить пароль
  companyModuleIbanProviderPassword(id: ID!): CompanyModuleIbanProviderPassword

  # Получить пароль
  companyModuleProviderPassword(id: ID!): CompanyModulePaymentProviderPassword
  country(id: ID): Country

  # Получить валюту по ID
  currency(id: ID): Currencies

  # Получить статистику по акаунтам
  dashboardAccountsStatistic(
    created_at: DateTimeRange
    payment_provider_id: ID
  ): [dashboardAccountsStatistic]

  # Получить статистику по тикетам
  dashboardTicketsStatistic(
    created_at: DateTimeRange
  ): [dashboardTicketsStatistic]

  # Получить статистику по трансферам
  dashboardTransfersStatistic(
    created_at: DateTimeRange
    company_id: ID
    payment_bank_id: ID
    payment_provider_id: ID
    payment_system_id: ID
  ): [dashboardTransfersStatistic]

  # Получить статистику по пользователям
  dashboardUsersStatistic(
    company_id: ID
    created_at: DateTimeRange
    project_id: ID
  ): [dashboardUsersStatistic]

  # Получить департамент по его ID
  department(id: ID): Department

  # Получить должность по ID
  departmentPosition(id: ID): DepartmentPosition

  # Получить список ducument states
  documentStates: [DocumentState!]!

  # Получить список ducument types
  documentTypes: [DocumentType!]!

  # Получить email notification
  emailNotification(
    company_id: ID!
    group_role_id: ID!
    group_type_id: ID!
    client_id: ID
  ): EmailNotification

  # Получить по smtp setting по ID
  emailSmtp(id: ID!): EmailSmtp

  # Получить список smtp настроек для компании
  emailSmtps(
    company_id: ID!
    orderBy: [QueryEmailSmtpsOrderByOrderByClause!]
  ): [EmailSmtp!]!

  # Получить по билет ID
  emailTemplateLayout(company_id: ID): EmailTemplateLayout

  # Получить по билет ID
  emailTemplate(id: ID): EmailTemplate

  # Получить список билетов
  # orderBy: [
  # {column: ID, order: DESC},
  # ] сортировка по ID
  emailTemplates(
    filter: QueryEmailTemplatesFilterFilterConditions
    created_at: DateTimeRange
    orderBy: [QueryEmailTemplatesOrderByOrderByClause!]
  ): [EmailTemplate!]!

  # Получить список
  employees: [Employee!]!

  # Получить деталии фи
  feeDetails(id: ID!): Fee!

  # Получить список
  feeModes: [FeeMode!]!

  # Получить список  периодов комиссий
  feePeriods: [FeePeriod!]!

  # Получить список статусов
  # фильтр по operation_type:
  # HAS_OPERATION_TYPE_FILTER_BY_ID
  feeTypes(filter: QueryFeeTypesFilterFilterConditions): [FeeType!]!

  # Получить файл по ID
  file(id: ID): Files

  # Получить тип группы по ID
  group_type(id: ID): GroupType

  # Получить список типов групп
  group_types(filter: QueryGroupTypesFilterFilterConditions): [GroupType!]!

  # Получить запись
  kycTimeline(id: ID!): KycTimeline

  # Получить список
  kycTimelines(
    applicant_id: ID!
    applicant_type: ApplicantType!
    company_id: ID!
    page: Int = 1
    first: Int = 15
    orderBy: [QueryKycTimelinesOrderByOrderByClause!]
  ): KycTimelines

  # Получить участника по ID
  memberAccessLimitation(id: ID): MemberAccessLimitation

  # Получить профиль пользователя
  memberProfile: MemberProfile

  # Получить список статусов мембера
  memberStatuses: [MemberStatus!]!

  # Получить участника по ID
  member(id: ID): Members

  # Получить модуль по ID
  module(id: ID): Module

  # Получить список модулей
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  modules(
    where: QueryModulesWhereWhereConditions
    orderBy: [QueryModulesOrderByOrderByClause!]
  ): [Module!]!

  # Получить список модулей вместе с модулем KYC
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  modulesWithKyc(
    where: QueryModulesWithKycWhereWhereConditions
    orderBy: [QueryModulesWithKycOrderByOrderByClause!]
  ): [Module!]

  # Получить список типов операций
  operationTypes(
    filter: QueryOperationTypesFilterFilterConditions
  ): [OperationType!]!

  # Получить банк по ID
  paymentBank(id: ID): PaymentBank

  # Получить провайдер по ID
  paymentProvider(id: ID): PaymentProvider

  # Получить запись
  paymentProviderIban(id: ID!): PaymentProviderIban!

  # Получить список статусов
  # фильтр по operation_type:
  # OPERATION_TYPE
  paymentStatuses(
    filter: QueryPaymentStatusesFilterFilterConditions
  ): [PaymentStatus!]!

  # Получить платежную систем по ID
  paymentSystem(id: ID): PaymentSystem

  # Получить уникальный список платежных систем
  paymentSystemsList: [PaymentSystem!]!

  # Получить список
  getPaymentUrgencys: [PaymentUrgency!]!
  senders: [Sender]

  # Получить платеж по ID
  payment(id: ID): Payments

  # Получить разрешение по ID
  permission(id: ID): Permissions

  # Получить список разрешений
  permissions_tree: Permissions
  permissions(where: QueryPermissionsWhereWhereConditions): [PermissionCategory]

  # Получить список Цен
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по имени, тип, тип операции, период
  priceListFees(
    filter: QueryPriceListFeesFilterFilterConditions
  ): [PriceListFee!]!

  # Получить компанию по ID
  project(id: ID): Project

  # Получить ProjectApiSettings
  projectApiSettings(project_id: ID!): [ProjectApiSetting!]!

  # Получить пароль
  projectApiSettingPassword(id: ID!): ProjectApiSettingPassword
  region(id: ID!): Region!

  # Получить реквизиты по ID
  requisite(id: ID): Requisite

  # Получить список реквизитов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  requisites(filter: QueryRequisitesFilterFilterConditions): [Requisite!]!

  # Скачать PDF с реквизитами
  downloadRequisiteDetails(account_id: ID): RawFile

  # Отправить реквизиты на email
  sendRequisiteDetails(
    # ID аккаунта
    account_id: ID!

    # Email
    email: String!
  ): StatusType

  # Получить список
  respondentFees: [RespondentFee!]!

  # Получить роль по ID
  role(id: ID): Role

  # Получить список
  states: [State!]!

  # Получить список
  stateReasons: [StateReason!]!

  # Получить по билет ID
  ticketComment(id: ID): TicketComments

  # Получить список
  getTicketComments: [TicketComments!]!

  # Получить по билет ID
  ticket(id: ID): Ticket

  # Получить трансфер
  transferIncoming(id: ID!): TransferIncoming!

  # Получить статистику по входящим платежам
  transferIncomingsStatistic(
    created_at: DateTimeRange
    company_id: ID
    payment_provider_id: ID
    account_id: ID
  ): [TransferIncomingStatistic]

  # Получить трансфер
  transferOutgoing(id: ID!): TransferOutgoing!

  # Получить статистику по исходящим платежам
  transferOutgoingsStatistic(
    created_at: DateTimeRange
    company_id: ID
    payment_provider_id: ID
    account_id: ID
  ): [TransferOutgoingStatistic]

  # Получить второй фактор по ID
  twoFactorAuth(id: ID): TwoFactorAuthSettings

  # Получить список
  typeOfIndustries: [TypeOfIndustry!]!
  userAuthData: userAuthResponse!

  # Получить список аккаунтов
  applicantAccounts(
    filter: QueryApplicantAccountsFilterFilterConditions
    orderBy: [QueryApplicantAccountsOrderByOrderByClause!]
  ): [ApplicantAccount!]

  # Получить список устройств пользователя
  applicantDevices: [ApplicantDevice!]

  # Получить профиль пользователя
  applicantProfile: ApplicantProfile

  # Получить реквизиты по Account_number
  applicantRequisite(account_number: String): ApplicantDetailsRequisites

  # Получить список реквизитов
  applicantRequisites: [ApplicantRequisites!]!

  # Скачать PDF с реквизитами
  downloadApplicantRequisiteDetails(account_id: ID): RawFile

  # Отправить реквизиты на email
  sendApplicantRequisiteDetails(
    # ID аккаунта
    account_id: ID!

    # Email
    email: String!
  ): StatusType

  # Получить список языков
  languages(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): LanguagesPaginator

  # Получить список лимитов
  accountLimits(
    filter: QueryAccountLimitsFilterFilterConditions
    orderBy: [QueryAccountLimitsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountLimitPaginator

  # Получить список лимитов
  accountReachedLimits(
    filter: QueryAccountReachedLimitsFilterFilterConditions
    hasAccount: QueryAccountReachedLimitsHasAccountWhereHasConditions
    where: QueryAccountReachedLimitsWhereWhereConditions
    orderBy: [QueryAccountReachedLimitsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountReachedLimitPaginator

  # Получить список аккаунтов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  accountList(
    filter: QueryAccountListFilterFilterConditions
    created_at: DateTimeRange
    orderBy: [QueryAccountListOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): AccountPaginator

  # Получить список частных пользователей
  # orderBy: [{ column: FIRST_NAME, order: DESC }] сортировка по ID, по имени, фамилии, email
  # where:{column: EMAIL, operator: LIKE, value: ""} фильтр по имени, фамилии, Email
  applicantIndividuals(
    filter: QueryApplicantIndividualsFilterFilterConditions
    group: Sort
    created_at: DateTimeRange
    company: Sort
    orderBy: [QueryApplicantIndividualsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualPaginator

  # Получить список applicant companies
  # orderBy: [{ column: FIRST_NAME, order: DESC }] сортировка по ID, по имени, фамилии, email
  # where:{column: EMAIL, operator: LIKE, value: ""} фильтр по имени, фамилии, Email
  applicantCompanies(
    filter: QueryApplicantCompaniesFilterFilterConditions
    where: QueryApplicantCompaniesWhereWhereConditions
    hasGroupRole: QueryApplicantCompaniesHasGroupRoleWhereHasConditions
    hasRiskLevel: QueryApplicantCompaniesHasRiskLevelWhereHasConditions
    hasStateReason: QueryApplicantCompaniesHasStateReasonWhereHasConditions
    hasStatus: QueryApplicantCompaniesHasStatusWhereHasConditions
    hasBusinessType: QueryApplicantCompaniesHasBusinessTypeWhereHasConditions
    hasOwner: QueryApplicantCompaniesHasOwnerWhereHasConditions
    hasKycLevel: QueryApplicantCompaniesHasKycLevelWhereHasConditions
    created_at: DateTimeRange
    group: Sort
    company: Sort
    orderBy: [QueryApplicantCompaniesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyPaginator

  # Получить все типы бизнеса
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantCompanyBusinessType(
    where: QueryApplicantCompanyBusinessTypeWhereWhereConditions
    orderBy: [QueryApplicantCompanyBusinessTypeOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyBusinessTypePaginator
  applicantCompanyLabelsAvailable(
    company_id: ID
    orderBy: [QueryApplicantCompanyLabelsAvailableOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyLabelPaginator

  # Получить список всех заметок
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantCompanyNotes(
    applicant_company_id: ID
    orderBy: [QueryApplicantCompanyNotesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyNotesPaginator

  # Получить историю списка уровней риска по аппликанту
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_id, operator: LIKE, value: ""} фильтр по аппликанту
  applicantCompanyRiskLevelHistory(
    filter: QueryApplicantCompanyRiskLevelHistoryFilterFilterConditions
    applicant_company_id: ID!
    where: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions
    orderBy: [QueryApplicantCompanyRiskLevelHistoryOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantCompanyRiskLevelHistoryPaginator

  # Получить список документов
  applicantDocuments(
    applicant_type: ApplicantType!
    filter: QueryApplicantDocumentsFilterFilterConditions
    created_at: DateTimeRange
    update_at: DateTimeRange
    orderBy: [QueryApplicantDocumentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantDocumentPaginator

  # Получить список заметок документа
  applicantDocumentInternalNotes(
    applicant_document_id: ID!

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantDocumentInternalNotePaginator

  # Получить список тегов документов
  applicantDocumentTags(
    filter: QueryApplicantDocumentTagsFilterFilterConditions
    orderBy: [QueryApplicantDocumentTagsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantDocumentTagPaginator

  # Получить список категорий тегов
  applicantDocumentTagCategories(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantDocumentTagCategoryPaginator

  # Получить все  должности
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualCompanyPositions(
    filter: QueryApplicantIndividualCompanyPositionsFilterFilterConditions
    orderBy: [QueryApplicantIndividualCompanyPositionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualCompanyPositionPaginator

  # Получить все  отношения
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantIndividualCompanyRelations(
    filter: QueryApplicantIndividualCompanyRelationsFilterFilterConditions
    orderBy: [QueryApplicantIndividualCompanyRelationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualCompanyRelationPaginator

  # Получить историю списка уровней риска по аппликанту
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: applicant_id, operator: LIKE, value: ""} фильтр по аппликанту
  applicantRiskLevelHistory(
    applicant_id: ID!
    where: QueryApplicantRiskLevelHistoryWhereWhereConditions
    orderBy: [QueryApplicantRiskLevelHistoryOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantRiskLevelHistoryPaginator

  # Получить список уровней KYC
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantKycLevels(
    where: QueryApplicantKycLevelsWhereWhereConditions
    orderBy: [QueryApplicantKycLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantKycLevelPaginator
  applicantIndividualLabelsAvailable(
    applicant_id: ID
    orderBy: [QueryApplicantIndividualLabelsAvailableOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualLabelPaginator

  # Получить список модулей
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  applicant_modules(
    where: QueryApplicantModulesWhereWhereConditions
    orderBy: [QueryApplicantModulesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantModulesPaginator

  # Получить список всех заметок
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по ID, по времени создания
  applicantIndividualNotes(
    applicant_individual_id: ID
    orderBy: [QueryApplicantIndividualNotesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantIndividualNotesPaginator

  # Получить список уровней риска
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantRiskLevels(
    where: QueryApplicantRiskLevelsWhereWhereConditions
    orderBy: [QueryApplicantRiskLevelsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantRiskLevelPaginator

  # Получить все состояния
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStates(
    where: QueryApplicantStatesWhereWhereConditions
    orderBy: [QueryApplicantStatesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStatePaginator

  # Получить все причины
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStateReasons(
    where: QueryApplicantStateReasonsWhereWhereConditions
    orderBy: [QueryApplicantStateReasonsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStateReasonPaginator

  # Получить все статусы
  # orderBy: [{ column: NAME, order: DESC }] сортировка по ID, по названию
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  applicantStatuses(
    where: QueryApplicantStatusesWhereWhereConditions
    orderBy: [QueryApplicantStatusesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): ApplicantStatusPaginator

  # Получить список
  bankCorrespondents(
    filter: QueryBankCorrespondentsFilterFilterConditions
    orderBy: [QueryBankCorrespondentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): BankCorrespondentPaginator

  # Получить список всех бизнесов
  businessActivities(
    filter: QueryBusinessActivitiesFilterFilterConditions
    orderBy: [QueryBusinessActivitiesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): BusinessActivityPaginator

  # Получить список прайсов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  commissionPriceLists(
    filter: QueryCommissionPriceListsFilterFilterConditions
    paymentProviderName: Sort
    orderBy: [QueryCommissionPriceListsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionPriceListPaginator

  # Получить список шаблонов
  # orderBy: [{ column: ID, order: DESC }] сортировка ID, NAME, IS_ACTIVE
  # filter:{column: NAME, operator: LIKE, value: ""} фильтр по name
  commissionTemplates(
    filter: QueryCommissionTemplatesFilterFilterConditions
    paymentProviderName: Sort
    orderBy: [QueryCommissionTemplatesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplatePaginator

  # Получить список лимитов
  commissionTemplateLimits(
    filter: QueryCommissionTemplateLimitsFilterStatic

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitPaginator

  # Получить список типов лимитов
  commissionTemplateLimitActionTypes(
    where: QueryCommissionTemplateLimitActionTypesWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitActionTypesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitActionTypePaginator

  # Получить список типов лимитов
  commissionTemplateLimitPeriods(
    where: QueryCommissionTemplateLimitPeriodsWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitPeriodsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitPeriodPaginator

  # Получить список направлений
  commissionTemplateLimitTransferDirections(
    where: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitTransferDirectionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitTransferDirectionPaginator

  # Получить список типов лимитов
  commissionTemplateLimitTypes(
    where: QueryCommissionTemplateLimitTypesWhereWhereConditions
    orderBy: [QueryCommissionTemplateLimitTypesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CommissionTemplateLimitTypePaginator

  # Получить список компаний
  # member_count: сортировка по количеству участников компании
  # county: сортировка по  стране
  # orderBy: [{ column: CREATED_AT, order: DESC }] сортировка по дате создания, по ID, по названию, email, url
  # created_at: {from:"2021-10-11", to: "2021-10-12"} фильтр по дате
  companies(
    filter: QueryCompaniesFilterFilterConditions
    created_at: DateTimeRange
    country: Sort
    member_count: Sort
    orderBy: [QueryCompaniesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 100

    # The offset from which items are returned.
    page: Int
  ): CompanyPaginator

  # Получить список стран
  countries(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CountryPaginator

  # Получить список валют
  currencies(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): CurrenciesPaginator

  # Получить список департаментов
  # orderBy: [{ column: ID, order: DESC }] сортировка по названию или по ID
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию
  # hasCompany: {column:ID,operator:EQ,value:1} фильтр по id компании
  departments(
    filter: QueryDepartmentsFilterFilterConditions
    created_at: DateTimeRange
    orderBy: [QueryDepartmentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): DepartmentPaginator

  # Получить список должностей
  # orderBy: [{ column: ID, order: DESC }] сортировка по названию, по ID, по is_active
  # where:{column: NAME, operator: LIKE, value: ""} фильтр по названию, по полю is_active
  # hasDepartment: {column:ID,operator:EQ,value:1} фильтр по id департамента
  departmentPositions(
    company_id: ID
    filter: QueryDepartmentPositionsFilterFilterConditions
    orderBy: [QueryDepartmentPositionsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): DepartmentPositionPaginator

  # Получить список email notification
  # orderBy: [
  # {column: ID, order: DESC},
  # ] сортировка по ID
  # where:{column: TYPE, operator: EQ, value: ""} фильтр по типу нотификаций
  emailNotifications(
    filter: QueryEmailNotificationsFilterFilterConditions
    created_at: DateTimeRange
    orderBy: [QueryEmailNotificationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): EmailNotificationPaginator

  # Получить список файлов
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  files(
    filter: QueryFilesFilterFilterConditions
    orderBy: [QueryFilesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): FilesPaginator

  # Получить список типов групп
  groupTypeList(
    mode: GroupTypeMode

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): GroupTypePaginator

  # Получить список групп с ролями
  # orderBy: [{ column: IS_ACTIVE, order: DESC }] сортировка по ID, статусу, описанию
  # where:{column: ID, operator: EQ, value: ""} фильтр по ID, ID группы, ID роли, ID платежного провайдера, ID шаблона комиссий, по статусу
  groups(
    filter: QueryGroupsFilterFilterConditions
    orderBy: [QueryGroupsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): GroupRolePaginator
  groupList(
    filter: QueryGroupListFilterFilterConditions
    orderBy: [QueryGroupListOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): GroupRoleViewPaginator

  # Получить список участников
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # filter:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  # hasPosition: {column: GROUP_ROLE_ID, operator:EQ, value: 8} поиск по id GROUP ROLE
  memberAccessLimitations(
    member_id: ID!
    filter: QueryMemberAccessLimitationsFilterFilterConditions
    orderBy: [QueryMemberAccessLimitationsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): MemberAccessLimitationPaginator

  # Получить список участников
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  # hasPosition: {column: DEPARTMENT_ID, operator:EQ, value: 8} поиск по id департамента
  members(
    filter: QueryMembersFilterFilterConditions
    companyName: Sort
    group: Int
    orderBy: [QueryMembersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): MembersPaginator

  # Получить список банков
  paymentBanks(
    filter: QueryPaymentBanksFilterFilterConditions
    query: QueryPaymentBankCondition
    orderBy: [QueryPaymentBanksOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentBankPaginator

  # Получить список провайдеров
  # paymentProviderCountry: country_id - получить все провайдеры по стране
  # paymentProviderCurrency: currency_id - получить все провайдеры по валюте
  # orderBy: [{ column: ID, order: DESC }] сортировка ID, NAME, IS_ACTIVE
  # where:{column: NAME, operator: EQ, value: ""} фильтр по name
  # hasPaymentSystems: {column:NAME,operator:GTE,value:PaymentSystemName} фильтр по платежным системам
  paymentProviders(
    filter: QueryPaymentProvidersFilterFilterConditions
    orderBy: [QueryPaymentProvidersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentProviderPaginator

  # Получить список
  paymentProviderIbans(
    filter: QueryPaymentProviderIbansFilterFilterConditions
    orderBy: [QueryPaymentProviderIbansOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentProviderIbanPaginator

  # Получить список платежных систем
  paymentSystems(
    filter: QueryPaymentSystemsFilterFilterConditions
    orderBy: [QueryPaymentSystemsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 100

    # The offset from which items are returned.
    page: Int
  ): PaymentSystemPaginator

  # Получить список платежей
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # Фильтры по
  # hasCompany: {column:NAME,operator:GTE,value:CompanyName} фильтр по имени компании
  # hasAccounts: {column:ACCOUNT_ID,operator:GTE,value:AccountNumber} фильтр по account number
  # hasOwner: {column:NAME,operator:GTE,value:MemberName} фильтр по владельцу
  payments(
    filter: QueryPaymentsFilterFilterConditions
    AccountNumber: Sort
    created_at: DateTimeRange
    orderBy: [QueryPaymentsOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): PaymentsPaginator

  # Получить список проектов
  projects(
    filter: QueryProjectsFilterFilterConditions

    # Limits number of fetched items.
    first: Int = 100

    # The offset from which items are returned.
    page: Int
  ): ProjectPaginator

  # Получить список регионов
  regions(
    filter: QueryRegionsFilterFilterConditions

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): RegionPaginator

  # Получить список ролей
  # groups_sort: сортировка по количеству групп
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID или по названию
  # where: {column: name, operator: LIKE, value: "Name"}
  roles(
    groups_sort: Sort
    filter: QueryRolesFilterFilterConditions
    orderBy: [QueryRolesOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): RolePaginator

  # Получить список билетов
  # orderBy: [
  # {column: ID, order: DESC},
  # {relation: "company", column: "name"},
  # {relation: "department", column: "name"}
  # ] сортировка по ID, компании, позиционный отдел
  # hasCompany: {column: COMPANY_ID, operator:EQ, value: 1} поиск по id компании
  # hasDepartment: {column: DEPARTMENT_ID, operator:EQ, value: 1} поиск по id Департамента
  # hasPosition: {column: DEPARTMENT_POSITION_ID, operator:EQ, value: 1} поиск по id позици
  # hasMember: {column: MEMBER_ID, operator:EQ, value: 1} поиск по id мембера
  # hasClient: {column: CLIENT_ID, operator:EQ, value: 1} поиск по id Клиента
  # where:{column: TITLE, operator: LIKE, value: ""} фильтр по имени, статуса
  tickets(
    filter: QueryTicketsFilterFilterConditions
    created_at: DateTimeRange
    orderBy: [QueryTicketsOrderByRelationOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TicketPaginator

  # Получить список входящих платежей
  transferIncomings(
    filter: QueryTransferIncomingsFilterFilterConditions
    created_at: DateTimeRange

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TransferIncomingPaginator

  # Получить историю входящего платежа
  transferIncomingHistory(
    transfer_id: ID!

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TransferIncomingHistoryPaginator

  # Получить список исходящих платежей
  transferOutgoings(
    filter: QueryTransferOutgoingsFilterFilterConditions
    created_at: DateTimeRange

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TransferOutgoingPaginator

  # Получить историю исходящего платежа
  transferOutgoingHistory(
    transfer_id: ID!

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TransferOutgoingHistoryPaginator

  # Получить список
  twoFactorsAuth(
    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): TwoFactorAuthSettingsPaginator

  # Получить список пользователей системы
  # orderBy: [{ column: ID, order: DESC }] сортировка по ID
  # where:{column: FIRST_NAME, operator: LIKE, value: ""} фильтр по фамилии, имени, email, компании, роли, департаменту, должности
  users(
    filter: QueryUsersFilterFilterConditions
    orderBy: [QueryUsersOrderByOrderByClause!]

    # Limits number of fetched items.
    first: Int = 10

    # The offset from which items are returned.
    page: Int
  ): UsersPaginator
}

# Языки
type Languages {
  id: ID!

  # Язык
  name: String!

  # ISO код языка
  iso: String!
}

# Аккаунты
# Banking -> Account -> Account Limit
type AccountLimit {
  id: ID!

  # ID account
  account_id: ID

  # ID направления платежа
  commission_template_limit_transfer_direction_id: ID

  # Сумма лимита
  amount: Decimal

  # ID валюты лимита
  currency_id: ID

  # Валюта
  currency: Currencies

  # ID периода лимита
  commission_template_limit_period_id: ID

  # ID события лимита
  commission_template_limit_action_type_id: ID

  # количество срабатываний лимита
  period_count: Int

  # Получить типы лимита
  commission_template_limit_type: CommissionTemplateLimitType

  # Получить направления лимита
  commission_template_limit_transfer_direction: CommissionTemplateLimitTransferDirection

  # Получить периоды лимита
  commission_template_limit_period: CommissionTemplateLimitPeriod

  # Получить события лимита
  commission_template_limit_action_type: CommissionTemplateLimitActionType

  # Получить Account
  account: Account
}

# Decimal type
scalar Decimal

# Валюты
type Currencies {
  id: ID!

  # Название валюты
  name: String!

  # ISO код валюты
  code: String!

  # Количество знаков после запятой
  minor_unit: Int
}

# Типы лимитов шаблонов
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitType {
  id: ID!

  # Название
  name: String!
}

# Направления переводов лимитов шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitTransferDirection {
  id: ID!

  # Название
  name: String!
}

# Периоды шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitPeriod {
  id: ID!

  # Название
  name: String!
}

# Типы событий шаблонов комиссий
# Banking -> Commission Templates -> Template Settings
type CommissionTemplateLimitActionType {
  id: ID!

  # Название
  name: String!
}

# Аккаунты
# Banking -> Account -> Account List
type Account {
  id: ID!

  # Получить связанный код валюты
  currency: Currencies

  # Получить связанного владельца
  owner: ApplicantIndividual

  # Номер аккаунта
  account_number: String

  # Тип аккаунта
  account_type: AccountType

  # Получить связанного платежного провайдера
  payment_provider: PaymentProvider

  # Получить связанного платежного провайдера iban
  iban_provider: PaymentProviderIban

  # Получить связанного Пеймент систем
  payment_system: PaymentSystem

  # Получить банк
  payment_bank: PaymentBank

  # Получить связанный шаблон комиссии
  commission_template: CommissionTemplate

  # Получить групроле
  group: GroupRole

  # Получить тип группы
  group_type: GroupType

  # Получить или индивидуала или компании
  client: Client

  # Состояние аккаунта
  account_state: AccountState

  # Компания которой принадлежит аккаунт
  company: Company

  # Получить менеджера
  member: Members

  # Все аккаунты клиента
  client_accounts: [ClientAccountsDetails!]!

  # Имя аккаунта
  account_name: String!

  # Основной или нет
  is_primary: Boolean

  # лимит максимального баланса
  min_limit_balance: Decimal

  # лимит минимального баланса
  max_limit_balance: Decimal
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
  activated_at: DateTimeUtc
  last_charge_at: DateTimeUtc
}

# Частный пользователь
# Management -> New Applicant -> Create Individual -> General
type ApplicantIndividual {
  id: ID!

  # Имя
  first_name: String

  # Фамилия
  last_name: String

  # Отчество
  middle_name: String

  # email
  email: EMAIL

  # Адрес сайта
  url: String

  # Телефон
  phone: String

  # Статус верецификации email
  email_verification: ApplicantVerificationStatus

  # Статус верецификации телефона
  phone_verification: ApplicantVerificationStatus

  # Получить связанную страну
  country: Country

  # Получить язык
  language: Languages

  # Получить связанную страну гражданства
  citizenship_country: Country

  # Штат / область
  state: String

  # Город
  city: String

  # Адрес
  address: String

  # Индекс
  zip: String

  # Национальность
  nationality: String

  # Получить связанную страну рождения
  birth_country: Country

  # Штат/область рождения
  birth_state: String

  # Город рождения
  birth_city: String

  # Дата рождения
  birth_at: Date

  # Пол
  sex: Sex

  # Время создания
  created_at: DateTimeUtc

  # Время обновления
  updated_at: DateTimeUtc

  # Дополнительные поля Profile data
  profile_additional_fields: JSON

  # Дополнительные поля для Personal info
  personal_additional_fields: JSON

  # Дополнительные поля блока контакты
  contacts_additional_fields: JSON

  # Полное имя
  fullname: String

  # время последний просмотренный
  last_screened_at: DateTimeUtc

  # Дополнительные поля
  address_additional_fields: JSON

  # Получить статусы
  status: ApplicantStatus

  # Получить состояния
  applicant_state: ApplicantState

  # Получить причины
  state_reason: ApplicantStateReason

  # Получить уровни рисков
  risk_level: ApplicantRiskLevel

  # Получить менеджера
  manager: Members

  # Получить метки
  labels: [ApplicantIndividualLabel]

  # Название компании держателя applicant
  company: Company

  # Получить заметки
  notes: [ApplicantIndividualNotes]

  # Получить модули
  modules: [ApplicantIndividualModules]

  # Получить компании к которым принадлежит апликант
  applicant_companies: [ApplicantCompany]

  # Получить группу
  group: GroupRole

  # Фото
  photo: Files

  # Получить проект
  project: Project

  # Получить two factor auth
  two_factor_auth: TwoFactorAuthSettings

  # Security PIN
  security_pin: String

  # Google Secret
  google2fa_secret: String

  # Backup Codes
  backup_codes: JSON

  # IP адрес
  ip_addresses: [ClientIpAddress]

  # Applicant KYC Level
  kyc_level: ApplicantKycLevel

  # Applicant Banking Access
  banking_access: [ApplicantBankingAccess]
}

# A [RFC 5321](https://tools.ietf.org/html/rfc5321) compliant email.
scalar EMAIL

type ApplicantVerificationStatus {
  # ID
  id: ID!

  # Название
  name: String!
}

# Страна
type Country {
  id: ID!

  # Название страны
  name: String!

  # 3х значный ISO код
  iso: String!
}

scalar Date

enum Sex {
  Male
  Female
}

scalar DateTimeUtc

# Arbitrary data encoded in JavaScript Object Notation. See https://www.json.org/.
scalar JSON

# Статусы
# Management -> New Applicant -> Create Individual -> General
type ApplicantStatus {
  id: ID!

  # Название
  name: String!
}

# Состояния
# Management -> New Applicant -> Create Individual -> General
type ApplicantState {
  id: ID!

  # Название
  name: String!
}

# State reason
# Management -> New Applicant -> Create Individual -> General
type ApplicantStateReason {
  id: ID!

  # Название
  name: String!
}

# Уровни риска
# Management -> New Applicant -> Create Individual -> General
type ApplicantRiskLevel {
  id: ID!

  # Название
  name: String!
}

# Участники
# Administration->Members
type Members {
  id: ID!

  # Имя участника
  first_name: String

  # Фамилия участника
  last_name: String

  # Email участника
  email: EMAIL

  # Пол участника
  sex: Sex

  # Статус участника
  member_status: MemberStatus

  # Последняя авторизация
  last_login_at: DateTimeUtc

  # получить компанию участника
  company: Company

  # получить страну участника
  country: Country

  # Получить язык участника
  language: Languages

  # Получить группу участника
  group: GroupRole

  # Получить должность
  position: DepartmentPosition

  # Получить департамент
  department: Department

  # ID настройки двухфактороной авторизации
  two_factor_auth_setting_id: ID

  # Получить настройки двухфакторной авторизации
  two_factor_auth_settings: TwoFactorAuthSettings

  # Дополнительны поля
  additional_fields: JSON

  # Дополнительны поля для member info
  additional_info_fields: JSON

  # Полное имя
  fullname: String

  # Access limitation groups
  access_groups: [MemberAccessLimitation]

  # если true видит только своих аппликантов
  is_show_owner_applicants: Boolean

  # Security PIN
  security_pin: String

  # Google Secret
  google2fa_secret: String

  # Member Backup Codes
  backup_codes: JSON

  # Подписывать или нет транзакцию
  is_sign_transaction: Boolean

  # Member ip address
  ip_addresses: [ClientIpAddress]

  # Верификация email
  email_verification: EmailVerification

  # Фото
  photo: Files

  # Должность
  job_title: String

  # Дата создания
  created_at: DateTimeUtc
}

# Статусы мембера
type MemberStatus {
  # ID
  id: ID!

  # Название
  name: String!
}

# Компания
# Administration->Company Info
# error codes: 500, 400
type Company {
  id: ID!

  # Название компании
  name: String!

  # URL компании
  url: String

  # E-mail компании
  email: EMAIL!

  # Регистрационный номер компании
  company_number: String

  # Модули компании
  company_modules: [CompanyModule]

  # Контактное лицо
  contact_name: String

  # Страна
  country: Country

  # Индекс
  zip: String

  # Город
  city: String

  # Адресс
  address: String

  # Участники компании
  members: [Members]

  # Количество участников в компании
  members_count: Int

  # Количество проектов
  projects_count: Int

  # Департаменты компании
  projects: [Project]

  # Департаменты компании
  departments: [Department]

  # Должности компании
  positions: [DepartmentPosition]

  # Дополнительные поля
  additional_fields_info: JSON

  # Телефон
  phone: String

  # Адрес регистрации
  reg_address: String
  tax_id: String
  incorporate_date: DateTimeUtc

  # Количество сотрудниуов
  employees: Employee

  # Область деятельности
  type_of_industry: TypeOfIndustry

  # Номер лицензии
  license_number: String

  # Дата окончания лицензии
  exp_date: DateTimeUtc

  # Состояние
  state: State

  # Причина состояния
  state_reason: StateReason

  # Регистрационный номер
  reg_number: String

  # Тип сущности
  entity_type: String

  # Дополнительные поля основные
  additional_fields_basic: JSON

  # Дополнительные поля настройки
  additional_fields_settings: JSON

  # Дополнительные поля данные
  additional_fields_data: JSON

  # Лого
  logo: Files

  # Токен для видеоверификации
  vv_token: String

  # Url верификации мембера
  member_verify_url: String

  # Backoffice login URL
  backoffice_login_url: String

  # Backoffice forgot password URL
  backoffice_forgot_password_url: String

  # Backoffice support URL
  backoffice_support_url: String

  # Backoffice support EMAIL
  backoffice_support_email: EMAIL
  created_at: DateTimeUtc!
  updated_at: DateTimeUtc!
}

# Модули компаний
type CompanyModule {
  # ID
  id: ID!

  # Модуль
  module: Module

  # Платежные провайдеры
  payment_providers: [CompanyModulePaymentProvider]

  # IBAN провайдеры
  iban_providers: [CompanyModuleIbanProvider]

  # Активность
  is_active: Boolean!
}

# Управление модулями
# Dashboard -> Applicants -> Company->Full Profile -> Settings
type Module {
  id: ID!

  # Название модуля
  name: String!
}

# Company Module Payment Provider
type CompanyModulePaymentProvider {
  # ID
  id: ID!

  # ID модуля компании
  company_module_id: ID!

  # ID платежного провайдера
  payment_provider: PaymentProvider!

  # Активность
  is_active: Boolean!
}

# Платежные провайдеры
# Banking -> Payment Providers
type PaymentProvider {
  id: ID!

  # Название провайдера
  name: String!

  # Описание провайдера
  description: String

  # Лого
  logo: Files

  # Активен или нет
  is_active: Boolean

  # Получить связанные платежные системы
  payment_systems: [PaymentSystem]
  commission_price_list: CommissionPriceList
  company: Company
}

# Файлы
type Files {
  id: ID!

  # Исходное имя файла
  file_name: String!

  # Тип файла
  mime_type: String!

  # Размер загружаемого файла
  size: Int!

  # Тип сущности для которой загружается файл
  entity_type: FileEntityTypeEnum!

  # Кто загружал файл
  author_id: Int!

  # Путь к загруженному файлу на ovh
  storage_path: String!

  # Название файла на ovh
  storage_name: String!

  # Ссылка на файл
  link: String!
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

enum FileEntityTypeEnum {
  MEMBER
  COMPANY
  DOCUMENT
  APPLICANT_INDIVIDUAL
  APPLICANT_COMPANY
  APPLICANT
  PROJECT
  FILE
}

# Платежные системы
# Settings->Payment System
type PaymentSystem {
  id: ID!

  # Название платежной системы
  name: String!

  # Активна или нет
  is_active: Boolean

  # Получить связанные регионы
  regions: [Region]

  # Получить связанную компанию
  company: Company

  # Получить связанные валюты
  currencies: [Currencies]

  # Получить Платежные провайдеры
  providers: PaymentProvider

  # Получить Реквизиты
  banks: [PaymentBank]

  # Получить банк корреспондент
  bank_correspondent: BankCorrespondent

  # Получить типы операций
  operations: [OperationType]

  # Описание
  description: String

  # Лого
  logo: Files
}

# Регион
type Region {
  id: ID!

  # Название региона
  name: String!

  # Получать страны
  countries: [Country]

  # Получать компанию
  company: Company
}

# Банки
# Settings->Payment System -> Payment System List -> Profile
type PaymentBank {
  id: ID!

  # Название банка
  name: String!

  # Адрес банка
  address: String

  # Код банка
  bank_code: String

  # Код платежной системы
  payment_system_code: String

  # Страна
  country: Country

  # Получить банк корреспондент
  bank_correspondent: BankCorrespondent

  # Платежная провидер
  payment_provider: PaymentProvider

  # Платежная система
  payment_system: PaymentSystem

  # Активный не активный (true/false)
  is_active: Boolean
}

# Bank correspondents
type BankCorrespondent {
  # ID
  id: ID!

  # Название
  name: String!

  # Адрес
  address: String!

  # SWIFT
  bank_code: String!

  # Счет банка корреспондента
  bank_account: String!

  # Получить валюты
  currencies: [Currencies]

  # Получить регионы
  regions: [Region]

  # Активность
  is_active: Boolean
}

# Типы операций
type OperationType {
  id: ID
  name: String
}

# Прайс лист комиссий
# Banking -> Commission Price List
type CommissionPriceList {
  id: ID!

  # Название шаблона
  name: String!

  # Получить связанный платежный провайдер
  provider: PaymentProvider

  # Получить связанного мембера
  owner: [ApplicantIndividual]

  # Получить связанный аккаунт
  account: Account

  # Получить связанную платежную систему
  payment_system: PaymentSystem

  # Получить связанный платежный шаблон
  commission_template: CommissionTemplate

  # Получить связанные цены
  fees: [PriceListFee]

  # Получить Регион
  region: Region

  # Получить компанию
  company: Company
}

# Шаблоны комиссий
# Banking -> Commission Templates -> Template List
type CommissionTemplate {
  id: ID!

  # Название шаблона
  name: String!

  # Описание шаблона
  description: String

  # Активен или нет
  is_active: Boolean

  # массив ID стран
  country_id: [ID]

  # массив ID валют
  currency_id: [ID]

  # Получить связанный платежный провайдер
  payment_provider: PaymentProvider

  # Получить список бизнесов
  business_activity: [BusinessActivity]

  # Получить связанного мембера
  owner: [ApplicantIndividual]

  # Получить связанный аккаунт
  account: Account

  # Получить компанию
  company: Company
  regions: [Region]
  currencies: [Currencies]
  commission_template_limits: [CommissionTemplateLimit]
}

# Business Activity
# Banking -> Commission Templates -> Template Settings
type BusinessActivity {
  id: ID!

  # Название
  name: String!
}

# Лимиты комиссий
# Banking -> Commission Templates -> Template List
type CommissionTemplateLimit {
  id: ID!

  # Сумма лимита
  amount: Decimal!

  # Валюта
  currency: Currencies!

  # количество срабатываний лимита
  period_count: Int

  # Получить типы лимита
  commission_template_limit_type: CommissionTemplateLimitType!

  # Получить направления лимита
  commission_template_limit_transfer_direction: CommissionTemplateLimitTransferDirection!

  # Получить периоды лимита
  commission_template_limit_period: CommissionTemplateLimitPeriod

  # Получить события лимита
  commission_template_limit_action_type: CommissionTemplateLimitActionType!

  # Получить шаблон комиссии
  commission_template: CommissionTemplate!

  # Получить платежную систему
  payment_system: PaymentSystem!

  # Получить регион
  region: Region!
}

# Цены прайс листа
# Banking -> Цены прайс листа
type PriceListFee {
  id: ID!

  # Название
  name: String!

  # Тип
  fee_type: FeeType

  # Тип операции
  operation_type: OperationType

  # Период
  period: FeePeriod

  # Цены
  fees: [PriceListFeeCurrency]
  price_list_id: ID
  fee_ranges: JSON
  scheduled: PriceListFeeScheduled
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

# Типы платежей
type FeeType {
  id: ID!

  # Название
  name: String!
}

# Периоды комиссий
type FeePeriod {
  id: ID
  name: String
}

type PriceListFeeCurrency {
  id: ID!
  currency_id: ID!
  price_list_fee_id: ID!
  fee: [FeeItem]
}

type FeeItem {
  mode: String!
  fee: Int
  amount_from: Int
  amount_to: Int
  percent: Int
}

type PriceListFeeScheduled {
  starting_date: DateTimeUtc
  end_date: DateTimeUtc
  recurrent_interval: Int
  starting_date_id: ID
  end_date_id: ID
}

# Company Module IBAN Provider
type CompanyModuleIbanProvider {
  # ID
  id: ID!

  # ID модуля компании
  company_module_id: ID!

  # ID IBAN провайдера
  payment_provider_iban: PaymentProviderIban!

  # Активность
  is_active: Boolean!
}

# Payment Provider Iban
type PaymentProviderIban {
  # ID
  id: ID!

  # Название
  name: String!

  # Получить компанию
  company: Company

  # Получить валюту
  currency: Currencies

  # Активность
  is_active: Boolean
}

type Project {
  id: ID!

  # Название проекта
  name: String!

  # URL
  url: String

  # Описание
  description: String

  # Email поддержки
  support_email: String

  # URL входа
  login_url: String

  # Имя отправителя SMS
  sms_sender_name: String

  # URL клиента
  client_url: String

  # URL восстановления пароля
  forgot_password_url: String

  # Дополнительны поля
  additional_fields_basic: JSON

  # Дополнительные поля настройки
  additional_fields_settings: JSON

  # Настройки проекта
  project_settings: [ProjectSettings]

  # Настройки api проекта
  project_api_settings: [ProjectApiSetting]

  # Модуль
  module: Module

  # Компания
  company: Company

  # Аватар
  avatar: Files

  # Состояние
  state: State
  created_at: DateTimeUtc!
  updated_at: DateTimeUtc!
}

# Настройки проекта
type ProjectSettings {
  # Тип группы
  group_type: GroupType

  # Роль
  group_role: GroupRole

  # Связанный платежный провайдер
  payment_provider: PaymentProvider

  # Связанный iban провайдер
  iban_provider: PaymentProviderIban

  # Связанный платежный шаблон
  commission_template: CommissionTemplate

  # Индивидуал или компани
  applicant_type: ApplicantType!
}

# Группы
type GroupType {
  id: ID!

  # Название группы
  name: GroupsEntities!
}

# Список групп
# Settings->Manager Groups->Groups List
enum GroupsEntities {
  Member
  Company
  Individual
}

type GroupRole {
  id: ID!

  # Название группы
  name: String

  # ID типа группы
  group_type_id: ID

  # ID роли
  role_id: ID

  # ID модуля
  module_id: ID

  # Описание группы
  description: String

  # Активная и не активная группа
  is_active: Boolean

  # Получить тип группы
  group_type: GroupType

  # Получить связанную роль
  role: Role

  # Получить провайдеров
  providers: [GroupRoleProvider]

  # Получить компанию
  company: Company

  # Получить связанный модуль
  module: Module
}

# Роли
# Settings->Manager Roles->Roles List
type Role {
  id: ID!

  # Название роли
  name: String!

  # Описание для роли
  description: String

  # Получить список полномочий
  permissions: [Permissions]

  # Получить список категорий полномочий
  permission_category_all_member: [PermissionCategory]

  # Получить дерево разрешений
  permissions_tree: JSON

  # Получить тип группы
  group_type: GroupType

  # Получить компанию
  company: Company

  # Получить список групп
  groups: [GroupRole]

  # Получить количество групп с данной ролью
  groups_count: Int
  is_all_companies: Boolean
}

# Список разрешений
# Settings->Manager Roles->Rol
type Permissions {
  id: ID
  name: String
  display_name: String
  guard_name: String
  type: String
  all: JSON
}

type PermissionCategory {
  id: ID
  name: String
  permissionList(
    permissionType: PermissionCategoryPermissionListPermissionTypeWhereConditions
  ): [PermissionList]
}

# Dynamic WHERE conditions for the `permissionType` argument on the query `permissionList`.
input PermissionCategoryPermissionListPermissionTypeWhereConditions {
  # The column that is used for the condition.
  column: PermissionCategoryPermissionListPermissionTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PermissionCategoryPermissionListPermissionTypeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PermissionCategoryPermissionListPermissionTypeWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: PermissionCategoryPermissionListPermissionTypeWhereConditionsRelation
}

# Allowed column names for PermissionCategory.permissionList.permissionType.
enum PermissionCategoryPermissionListPermissionTypeColumn {
  TYPE
}

# The available SQL operators that are used to filter query results.
enum SQLOperator {
  # Equal operator (`=`)
  EQ

  # Not equal operator (`!=`)
  NEQ

  # Greater than operator (`>`)
  GT

  # Greater than or equal operator (`>=`)
  GTE

  # Less than operator (`<`)
  LT

  # Less than or equal operator (`<=`)
  LTE

  # Simple pattern matching (`LIKE`)
  LIKE

  # Simple pattern matching (`ILIKE`)
  ILIKE

  # Negation of simple pattern matching (`NOT LIKE`)
  NOT_LIKE

  # Whether a value is within a set of values (`IN`)
  IN

  # Whether a value is not within a set of values (`NOT IN`)
  NOT_IN

  # Whether a value is within a range of values (`BETWEEN`)
  BETWEEN

  # Whether a value is not within a range of values (`NOT BETWEEN`)
  NOT_BETWEEN

  # Whether a value is null (`IS NULL`)
  IS_NULL

  # Whether a value is not null (`IS NOT NULL`)
  IS_NOT_NULL
}

# Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
# as they may not be parsed correctly on the server side. Use `String` literals if you are
# dealing with really large numbers to be on the safe side.
scalar Mixed

# Dynamic HAS conditions for WHERE conditions for the `permissionType` argument on the query `permissionList`.
input PermissionCategoryPermissionListPermissionTypeWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: PermissionCategoryPermissionListPermissionTypeWhereConditions
}

type PermissionList {
  id: ID
  name: String
  type: PermissionListType
  separator: PermissionSeparatorType
  permissions: [Permissions]
}

enum PermissionListType {
  Member
  Individual
}

enum PermissionSeparatorType {
  Private
  Business
}

type GroupRoleProvider {
  id: ID!

  # ID роль групп
  group_role_id: ID

  # Получить связанный платежный провайдер
  payment_provider: PaymentProvider

  # Получить связанный шаблон комиссий
  commission_template: CommissionTemplate

  # По умолчанию
  is_default: Boolean
}

enum ApplicantType {
  ApplicantIndividual
  ApplicantCompany
}

# Project Api Setting
type ProjectApiSetting {
  # ID
  id: ID!

  # ID проекта
  project: Project!

  # Кошелек
  wallet: String

  # API ключ
  api_key: String

  # Пароль
  password: String

  # Активен или нет
  is_active: Boolean

  # поставщик
  provider: ProviderType
}

union ProviderType = PaymentProvider | PaymentProviderIban

type State {
  # ID
  id: ID!

  # Название
  name: String!
}

# Департаменты
# Administration->Company Info->Full Profile->Department
type Department {
  id: ID!

  # Название департамента
  name: String!

  # Дата создания Департамент
  created_at: DateTimeUtc

  # Получить компанию
  company: Company

  # Получить должность
  positions: [DepartmentPosition]
}

# Должности
type DepartmentPosition {
  id: ID!

  # Назварие должности
  name: String!

  # Активен = true или не активный = false
  is_active: Boolean

  # Получить компанию
  company: Company

  # Получить департамент
  department: [Department]
}

type Employee {
  # ID
  id: ID!

  # Номер
  employees_number: String!
}

type TypeOfIndustry {
  # ID
  id: ID!

  # Название
  name: String!
}

type StateReason {
  # ID
  id: ID!

  # Название
  name: String!
}

# Методы двухфакторной авторизации
type TwoFactorAuthSettings {
  id: ID!

  # Название второго фактора
  name: String!
}

# Участники
# Administration->Members->MemberAccessLimitation
type MemberAccessLimitation {
  id: ID!

  # Получить компанию
  company: Company

  # Получить Group
  member: Members

  # Получить модуль
  module: Module

  # Получить GroupType
  group: GroupType

  # Получить groupRole
  group_roles: [GroupRole]

  # Получить проект
  project: Project

  # Получить связанный платежный провайдер
  provider: PaymentProvider

  # Показать только своих аппликантов
  see_own_applicants: Boolean
}

# Client ip address
type ClientIpAddress {
  id: ID!

  # ip_address
  ip_address: String

  # Client type
  client_type: String

  # Client ID
  client_id: ID
}

enum EmailVerification {
  NOT_VERIFIED
  REQUESTED
  VERIFIED
}

# Метки пользователя
# Management -> New Applicant -> Create Individual -> General
type ApplicantIndividualLabel {
  id: ID!

  # Название метки
  name: String!

  # HEX код метки
  hex_color_code: String!
  is_active: Boolean
}

# Заметки частный пользователь
# Dashboard -> Applicants -> Individual
type ApplicantIndividualNotes {
  id: ID!

  # Заметка
  note: String!

  # Дата и время создания
  created_at: DateTimeUtc

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantIndividual
}

# Модули аппликанта
# Dashboard -> Applicants -> Individual -> Full Profile -> Settings
type ApplicantIndividualModules {
  # ID
  id: ID

  # Название
  name: String

  # Активен = true или не активный = false
  is_active: Boolean
}

# Компания пользователя
# Management -> New Applicant -> Create Company
type ApplicantCompany {
  id: ID!

  # Название
  name: String

  # email
  email: EMAIL

  # Адрес сайта
  url: String

  # Телефон
  phone: String

  # Статус верецификации email
  email_verification: ApplicantVerificationStatus

  # Статус верецификации телефона
  phone_verification: ApplicantVerificationStatus

  # Получить связанную страну
  country: Country

  # Получить язык
  language: Languages

  # Штат / область
  state: String

  # Город
  city: String

  # Адрес
  address: String

  # Адрес2
  address2: String

  # Адрес офиса
  office_address: String

  # Индекс
  zip: String

  # Дата регистрации
  reg_at: Date

  # Дата окончания регистрации
  expires_at: Date

  # Налоговый номер
  tax: String

  # Регистрационный номер
  reg_number: String

  # Номер лицензии
  license_number: String

  # Тип компании
  company_type: String

  # Дополнительные поля Company Info
  company_info_additional_fields: JSON

  # Дополнительные поля блока контакты
  contacts_additional_fields: JSON

  # Дополнительные поля Profile data
  profile_additional_fields: JSON

  # Дата включуения
  incorporate_date: DateTimeUtc

  # Дополнительные поля Basic info
  basic_info_additional_field: JSON

  # Дата создания
  created_at: DateTimeUtc

  # Контактный email
  contact_email: EMAIL

  # Контактный телефон
  contact_phone: String

  # Получить тип бизнеса
  business_type: ApplicantCompanyBusinessType

  # Получить статусы
  status: ApplicantStatus

  # Получить состояния
  applicant_state: ApplicantState

  # Получить причины
  state_reason: ApplicantStateReason

  # Получить уровни рисков
  risk_level: ApplicantRiskLevel

  # Получить KYC level
  kyc_level: ApplicantRiskLevel

  # Получить менеджера
  manager: Members

  # Получить создателя
  owner: ApplicantIndividual

  # Получить метки
  labels: [ApplicantCompanyLabel]

  # Получить заметки
  notes: [ApplicantCompanyNotes]

  # Модули
  modules: [ApplicantCompanyModules]
  company_position: ApplicantIndividualCompany
  owner_relation: ApplicantIndividualCompany
  owner_position: ApplicantIndividualCompany
  company: Company

  # Получить группу
  group: GroupRole

  # Получить фото
  photo: Files

  # Проект
  project: Project
}

# Типы бизнеса для компании
# Management -> New Applicant -> Create Company
type ApplicantCompanyBusinessType {
  id: ID!

  # Название
  name: String!
}

# Метки компании
# Management -> New Applicant -> Create Company
type ApplicantCompanyLabel {
  id: ID!

  # Название метки
  name: String!

  # HEX код метки
  hex_color_code: String!
  is_active: Boolean
}

# Заметки компания
# Dashboard -> Applicants -> Company
type ApplicantCompanyNotes {
  id: ID!

  # Заметка
  note: String!

  # Дата и время создания
  created_at: DateTimeUtc

  # Получить автора
  author: Members

  # Получить пользователя
  applicant: ApplicantCompany
}

# Модули компании
# Dashboard -> Applicants -> Company -> Full Profile -> Settings
type ApplicantCompanyModules {
  # ID
  id: ID

  # Название
  name: String

  # Активен = true или не активный = false
  is_active: Boolean
}

type ApplicantIndividualCompany {
  applicant_id: ID!
  applicant_type: String!
  applicant_company_id: ID!
  applicant_company: ApplicantCompany
  applicant_individual_company_relation_id: ID!
  applicant_individual_company_position_id: ID!
  relation_to_company: ApplicantIndividualCompanyRelation
  position_in_company: ApplicantIndividualCompanyPosition
  percentage_owned: Float

  # Получить индивидуала или компанию индивидуала
  client: Client
}

# Отношения компании
# Management -> New Applicant -> Create Company
type ApplicantIndividualCompanyRelation {
  id: ID!

  # Название
  name: String!

  # Компания
  company: Company
}

# Должности компании
# Management -> New Applicant -> Create Company
type ApplicantIndividualCompanyPosition {
  id: ID!

  # Название должности
  name: String!

  # Компания
  company: Company
}

union Client = ApplicantIndividual | ApplicantCompany

# Уровни KYC
# Management -> New Applicant
type ApplicantKycLevel {
  id: ID!

  # Название
  name: String!
}

# Access for Online Banking
type ApplicantBankingAccess {
  id: ID!

  # Получить связанного applicant individual
  applicant_individual: ApplicantIndividual

  # Получить связанного applicant company
  applicant_company: ApplicantCompany

  # Получить связанного Member
  member: Members

  # Contact administrator
  contact_administrator: Boolean!

  # Ежедневный лимит
  daily_limit: Decimal!

  # Ежемесячный лимит
  monthly_limit: Decimal!

  # Лимит операций
  operation_limit: Decimal!

  # Ежедневный использованный лимит
  used_daily_limit: Decimal!

  # Ежемесячный использованный лимит
  used_monthly_limit: Decimal!

  # Получить роль
  role: Role

  # Доступ
  grant_access: Boolean
  create_payments: Boolean
  sign_payments: Boolean
}

enum AccountType {
  Private
  Business
}

type AccountState {
  id: ID!
  name: String!
  active: Boolean!
}

type ClientAccountsDetails {
  id: ID!

  # Текущий баланс
  current_balance: Decimal!

  # Текущий баланс
  reserved_balance: Decimal!

  # Текущий баланс
  available_balance: Decimal!

  # Получить связанный код валюты
  currency: Currencies!

  # лимит максимального баланса
  min_limit_balance: Decimal

  # лимит минимального баланса
  max_limit_balance: Decimal
}

# AccountReachedLimit
# Banking -> Account -> Account Limit
type AccountReachedLimit {
  id: ID!

  # ID account
  account_id: ID!

  # Получить Account
  account: Account

  # Тип
  group_type: String!

  # Имя аппликанта
  client_name: String!

  # Тип аппликанта
  client_type: String!

  # Тип трансфера
  transfer_direction: String!

  # Тип лимита
  limit_type: String!

  # Значение лимита
  limit_value: Int!

  # Валюта лимита
  limit_currency: String!

  # Период
  period: Int!

  # Сумма
  amount: Decimal!
}

input DateTimeRange {
  from: DateTimeUtc!
  to: DateTimeUtc!
}

type AccountStatement {
  account_number: String
  account_currency: String
  date_from: DateTimeUtc!
  opening_balance: Float
  opening_balance_date: DateTimeUtc
  closing_balance: Float
  closing_balance_date: DateTimeUtc
  debit_turnover: Float
  credit_turnover: Float
  transactions: [AccountStatementTransaction]
}

type AccountStatementTransaction {
  transaction_id: ID!
  created_at: DateTimeUtc!
  execution_at: DateTimeUtc
  sender_recipient: String
  reason: String
  amount: Float!
  account_number: String
  account_client: String
  status: String
  account_balance: Float
}

type RawFile {
  base64: String!
}

# Order by clause for Query.accountStates.orderBy.
input QueryAccountStatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountStatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountStates.orderBy.
enum QueryAccountStatesOrderByColumn {
  ID
  NAME
}

# Directions for ordering a list of records.
enum SortOrder {
  # Sort records in ascending order.
  ASC

  # Sort records in descending order.
  DESC
}

type AccountClient {
  id: ID!
  client: Client!
}

input QueryActiveSessionsStatic {
  company: String
  provider: String
  group: String
  created_at: Date
}

type ActiveSessions {
  data: [ActiveSession!]
  paginatorInfo: PaginatorInfo
}

type ActiveSession {
  # ID
  id: String!

  # Название компании
  company: String!

  # Группа
  provider: String!

  # Домен
  domain: String!

  # IP
  ip: String

  # Страна
  country: String

  # Город
  city: String

  # Платформа
  platform: String

  # Браузер
  browser: String

  # Версия браузера
  browser_version: String

  # Устройство
  device_type: String

  # Модель
  model: String

  # доверенный
  trusted: Boolean

  # Дата создания
  created_at: DateTimeUtc!
}

# Information about pagination using a fully featured paginator.
type PaginatorInfo {
  # Number of items in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the first item in the current page.
  firstItem: Int

  # Are there more pages after this one?
  hasMorePages: Boolean!

  # Index of the last item in the current page.
  lastItem: Int

  # Index of the last available page.
  lastPage: Int!

  # Number of items per page.
  perPage: Int!

  # Number of total available items.
  total: Int!
}

input QueryActivityLogsStatic {
  company: String
  member: String
  group: String
  domain: String
  created_at: Date
}

input OrderBy {
  column: Column!
  order: Order!
}

enum Column {
  EXPIRED_AT
  CREATED_AT
  ID
}

enum Order {
  ASC
  DESC
}

type ActivityLogs {
  data: [ActivityLog!]
  paginatorInfo: PaginatorInfo
}

type ActivityLog {
  # ID
  id: String!

  # Название компании
  company: String!

  # Группа
  member: String!

  # Группа
  group: String!

  # Домен
  domain: String!

  # Описание
  description: String

  # Изменения
  changes: String

  # Дата создания
  created_at: DateTimeUtc!
}

# Order by clause for Query.owners.orderBy.
input QueryOwnersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryOwnersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.owners.orderBy.
enum QueryOwnersOrderByColumn {
  ID
  EMAIL
  CREATED_AT
  FULLNAME
}

# Dynamic WHERE conditions for the `filter` argument on the query `grantedBankingAccess`.
input QueryGrantedBankingAccessFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryGrantedBankingAccessFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGrantedBankingAccessFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGrantedBankingAccessFilterFilterConditions!]
}

# Column names for Query.grantedBankingAccess.filter.
enum QueryGrantedBankingAccessFilterStatic {
  MEMBER_ID
  GRANT_ACCESS
}

# Order by clause for Query.grantedBankingAccess.orderBy.
input QueryGrantedBankingAccessOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGrantedBankingAccessOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.grantedBankingAccess.orderBy.
enum QueryGrantedBankingAccessOrderByColumn {
  ID
  APPLICANT_INDIVIDUAL_ID
  APPLICANT_COMPANY_ID
  MEMBER_ID
}

type ApplicantBankingAccesses {
  data: [ApplicantBankingAccess!]
  paginatorInfo: PaginatorInfo
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantBankingAccesses`.
input QueryApplicantBankingAccessesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantBankingAccessesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantBankingAccessesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantBankingAccessesFilterFilterConditions!]
}

# Column names for Query.applicantBankingAccesses.filter.
enum QueryApplicantBankingAccessesFilterStatic {
  MEMBER_ID
  GRANT_ACCESS
}

# Order by clause for Query.applicantBankingAccesses.orderBy.
input QueryApplicantBankingAccessesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantBankingAccessesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantBankingAccesses.orderBy.
enum QueryApplicantBankingAccessesOrderByColumn {
  ID
  APPLICANT_INDIVIDUAL_ID
  APPLICANT_COMPANY_ID
  MEMBER_ID
}

# Dynamic WHERE conditions for the `filter` argument on the query `getMatchedUsers`.
input QueryGetMatchedUsersFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryGetMatchedUsersFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGetMatchedUsersFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGetMatchedUsersFilterFilterConditions!]
}

# Column names for Query.getMatchedUsers.filter.
enum QueryGetMatchedUsersFilterStatic {
  APPLICANT_TYPE
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyLabels`.
input QueryApplicantCompanyLabelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyLabelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyLabelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyLabelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyLabelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyLabels.where.
enum QueryApplicantCompanyLabelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyLabels`.
input QueryApplicantCompanyLabelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyLabelsWhereWhereConditions
}

# Order by clause for Query.applicantCompanyLabels.orderBy.
input QueryApplicantCompanyLabelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyLabelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyLabels.orderBy.
enum QueryApplicantCompanyLabelsOrderByColumn {
  ID
  NAME
}

# Документы аппдиканта
type ApplicantDocument {
  # ID
  id: ID!

  # Добавлено из
  added_from: String
  applicant_id: ID!
  applicant_type: ApplicantType!
  document_type_id: ID
  document_state_id: ID
  company: Company

  # Получить страну
  country: Country
  document_type: DocumentType
  document_state: DocumentState

  # Получить файл
  file: Files
  info: String

  # Получить внутренние заметки документа
  internal_notes: [ApplicantDocumentInternalNote]

  # Получить теги
  tags: [ApplicantDocumentTag]

  # Получить детали отклонения документа
  reject_details: [ApplicantDocumentRejectDetail]

  # Дата создания
  created_at: DateTimeUtc

  # Дата обновления
  updated_at: DateTimeUtc
}

# Типы документов
type DocumentType {
  # ID
  id: ID!

  # Название
  name: String!
}

# Состояния документа
type DocumentState {
  # ID
  id: ID!

  # Название
  name: String!
}

# Внутренние заметки к документам аппликанта
type ApplicantDocumentInternalNote {
  # ID
  id: ID!

  # Получить документ
  document: ApplicantDocument

  # Получить Мембера
  member: Members

  # Текст заметки
  note: String

  # Дата создания
  created_at: DateTimeUtc

  # Дата обновления
  updated_at: DateTimeUtc
}

# Теги документов аппликанта
type ApplicantDocumentTag {
  # ID
  id: ID!

  # Категория
  category: ApplicantDocumentTagCategory

  # Имя
  name: String!

  # member
  member: Members

  # дата создания
  created_at: DateTimeUtc

  # Описание
  description: String
}

# Категории тегов документов аппликанта
type ApplicantDocumentTagCategory {
  # ID
  id: ID!

  # Имя категории
  name: String!
}

type ApplicantDocumentRejectDetail {
  # ID
  id: ID!

  # Документ
  applicant_document: ApplicantDocument!

  # Тег
  applicant_document_tag: [ApplicantDocumentTag!]

  # Мембер
  member: Members

  # Дата создания
  created_at: DateTimeUtc

  # Дата обновления
  updated_at: DateTimeUtc
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantIndividualLabels`.
input QueryApplicantIndividualLabelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualLabelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualLabelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualLabelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantIndividualLabelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantIndividualLabels.where.
enum QueryApplicantIndividualLabelsWhereColumn {
  NAME
  APPLICANT_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantIndividualLabels`.
input QueryApplicantIndividualLabelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantIndividualLabelsWhereWhereConditions
}

# Order by clause for Query.applicantIndividualLabels.orderBy.
input QueryApplicantIndividualLabelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualLabelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualLabels.orderBy.
enum QueryApplicantIndividualLabelsOrderByColumn {
  APPLICANT_ID
  NAME
}

type ApplicantLinkedCompany {
  company: ApplicantCompany
  company_position: ApplicantIndividualCompanyPosition
  company_relation: ApplicantIndividualCompanyRelation
  percentage_owned: Float
}

# Управление модулями
# Dashboard -> Applicants -> Company->Full Profile -> Settings
type ApplicantModules {
  id: ID!

  # Название модуля
  name: String!
}

input QueryAuthenticationLogsStatic {
  company: String
  member: String
  email: String
  client_type: String
  provider: String
  group: String
  domain: String
  ip: String
  country: String
  city: String
  platform: String
  browser: String
  device_type: String
  model: String
  status: String
  expired_at: Date
  created_at: Date
}

type AuthenticationLogs {
  data: [AuthenticationLog!]
  paginatorInfo: PaginatorInfo
}

type AuthenticationLog {
  # ID
  id: ID!

  # Название компании
  company: String!

  # Почта
  email: String!

  # Member email
  member: String!

  # Тип
  client_type: String!

  # Тип
  provider: String!

  # Группа
  group: String!

  # Домен
  domain: String!

  # IP
  ip: String

  # Страна
  country: String

  # Город
  city: String

  # Платформа
  platform: String

  # Браузер
  browser: String

  # Версия браузера
  browser_version: String

  # Устройство
  device_type: String

  # Модель
  model: String

  # Статус
  status: String

  # Инфо
  info: String

  # Дата истечения
  expired_at: DateTimeUtc

  # Дата создания
  created_at: DateTimeUtc!
}

type CompanyModuleIbanProviderPassword {
  # ID
  id: ID!

  # Пароль
  password: String!
}

type CompanyModulePaymentProviderPassword {
  # ID
  id: ID!

  # Пароль
  password: String!
}

type dashboardAccountsStatistic {
  account_state_id: ID!
  payment_provider_id: ID!
  payment_provider_name: String!
  account_state_name: String!
  count: Int!
}

type dashboardTicketsStatistic {
  status_id: ID!
  status_name: String!
  count: Int!
}

type dashboardTransfersStatistic {
  transfer_type: String!
  status_name: String!
  count: Int!
}

type dashboardUsersStatistic {
  applicant_type: String!
  status_name: String!
  count: Int!
}

# Шаблоны электронной почты
# Banking-> Email Notifications
type EmailNotification {
  id: ID!

  # Тип
  type: NotifyType

  # Тип получателя
  recipient_type: RecipientType

  # Тип Группы
  group_type: GroupType

  # Получить templates
  templates: [EmailTemplate]

  # Получить клиента ApplicantIndividual | ApplicantCompany | Members
  clientable: Clientable

  # Получить компанию
  company: Company

  # Получить Group Role
  group_role: GroupRole
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

enum NotifyType {
  Administration
  Client
}

enum RecipientType {
  PERSON
  GROUP
}

# Шаблоны электронной почты
# Banking-> Email Templates Settings
type EmailTemplate {
  id: ID!

  # Название
  name: String!

  # Тема
  subject: String!

  # Тип
  type: ClientType!

  # Тип сервиса
  service_type: ServiceType!

  # Контент
  content: String!

  # Получить Компанию
  company: Company

  # Получить Компанию
  layout: EmailTemplateLayout
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
  use_layout: Boolean
}

enum ClientType {
  Administration
  Client
}

enum ServiceType {
  BankingCommon
  BankingSystem
  Banking
  Common
  System
  AdminNotify
}

type EmailTemplateLayout {
  id: ID!

  # Header
  header: String!

  # Footer
  footer: String!

  # Ид компании
  company_id: Int!
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

union Clientable = ApplicantIndividual | ApplicantCompany | Members

# Шаблоны электронной почты
# Banking-> Email Templates Settings
type EmailSmtp {
  id: ID!

  # Защита
  security: Securities

  # Имя хоста
  host_name: String!

  # От кого
  from_name: String

  # почта
  from_email: String

  # логин
  username: String!

  # пароль
  password: String!

  # ответить кому
  replay_to: String

  # Порт
  port: Int!

  # Определяем отправлять через данные настройки всю почту или нет
  is_sending_mail: Boolean

  # Название шаблона
  name: String

  # Получить мембера
  member: Members

  # Получить компанию
  company: Company
}

enum Securities {
  Auto
  Ssl
  Starttls
}

# Order by clause for Query.emailSmtps.orderBy.
input QueryEmailSmtpsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailSmtpsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailSmtps.orderBy.
enum QueryEmailSmtpsOrderByColumn {
  ID
  NAME
}

# Dynamic WHERE conditions for the `filter` argument on the query `emailTemplates`.
input QueryEmailTemplatesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryEmailTemplatesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailTemplatesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailTemplatesFilterFilterConditions!]
}

# Column names for Query.emailTemplates.filter.
enum QueryEmailTemplatesFilterStatic {
  HAS_COMPANY_FILTER_BY_NAME
  NAME
  COMPANY_ID
  TYPE
  SERVICE_TYPE
}

# Order by clause for Query.emailTemplates.orderBy.
input QueryEmailTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailTemplates.orderBy.
enum QueryEmailTemplatesOrderByColumn {
  ID
}

type Fee {
  # Дата
  created_at: DateTimeUtc!
  fee: Decimal!
  fee_pp: Decimal!
  fee_amount: Decimal!

  # Трансфер
  transfer_outgoing: TransferOutgoing

  # Тип трансфера
  transfer_type: String!

  # Тип операции
  operation_type: OperationType
  price_list_fee: PriceListFee

  # Клиент (Индивидуал или Компани)
  client: Client

  # Получить связанного мембера
  member: Members

  # Получить связанный аккаунт
  account: Account

  # Статус
  status: PaymentStatus
}

# Исходящие переводы
type TransferOutgoing {
  id: ID!

  # Получить инициатора платежа (Мембер или Апликант)
  requested_by: Clientable

  # Тип инициатора платежа
  user_type: UserType

  # Сумма
  amount: Decimal!
  amount_debt: Decimal!

  # Коммиссия
  fee: Fee

  # Все коммиссии
  fees: [Fee]

  # Файлы
  files: [Files]

  # Получить связанную валюту
  currency: Currencies

  # Статус
  status: PaymentStatus

  # Получить связанныую срочность
  payment_urgency: PaymentUrgency

  # Получить связанный тип
  payment_operation_type: OperationType

  # Получить связанный провайдер
  payment_provider: PaymentProvider

  # Получить связанную информацию по провайдеру
  payment_provider_history: PaymentProviderHistory

  # Получить связанную платежную систему
  payment_system: PaymentSystem

  # Получить связанный банк
  payment_bank: PaymentBank

  # Номер платежа
  payment_number: String!

  # Получить связанный тип трансфера
  transfer_type: TypeOfTransfer

  # Получить связанный аккаунт
  account: Account

  # Получить отправителя (Индивидуал или Компани)
  sender: Client

  # Получить связанную компанию
  company: Company
  system_message: String
  reason: String
  channel: String
  bank_message: String

  # Номер счета или IBAN получателя
  recipient_account: String!
  recipient_bank_name: String!
  recipient_bank_address: String!
  recipient_bank_swift: String
  recipient_bank_country: Country
  recipient_name: String!
  recipient_country: Country
  recipient_city: String!
  recipient_address: String!
  recipient_state: String!
  recipient_zip: String!
  respondent_fee: RespondentFee

  # Дата и время выполнения транзакции
  execution_at: DateTimeUtc
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

enum UserType {
  ApplicantIndividual
  ApplicantCompany
  Members
}

# Типы платежей
type PaymentStatus {
  id: ID!

  # Название
  name: String!
}

# Срочность
type PaymentUrgency {
  id: ID!

  # Название
  name: String!
}

type PaymentProviderHistory {
  # ID
  id: ID!

  # ID провайдера
  payment_provider_id: ID!

  # ID трансфера
  transfer_id: ID!

  # Тип трансфера
  transfer_type: String

  # Информация от провайдера
  provider_response: JSON

  # Дата создания
  created_at: DateTimeUtc
}

type TypeOfTransfer {
  id: ID!
  name: String!
}

type RespondentFee {
  id: ID!

  # Название
  name: String!
}

type FeeMode {
  # ID
  id: ID!

  # Название
  name: String!
}

# Dynamic WHERE conditions for the `filter` argument on the query `feeTypes`.
input QueryFeeTypesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryFeeTypesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryFeeTypesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryFeeTypesFilterFilterConditions!]
}

# Column names for Query.feeTypes.filter.
enum QueryFeeTypesFilterStatic {
  HAS_OPERATION_TYPE_FILTER_BY_ID
}

# Dynamic WHERE conditions for the `filter` argument on the query `group_types`.
input QueryGroupTypesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryGroupTypesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupTypesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupTypesFilterFilterConditions!]
}

# Column names for Query.group_types.filter.
enum QueryGroupTypesFilterStatic {
  HAS_GROUPS_FILTER_BY_COMPANY_ID
  HAS_GROUPS_FILTER_BY_ROLE_ID
  HAS_ROLES_FILTER_BY_ID
}

# KYC Timeline
type KycTimeline {
  # ID
  id: ID!

  # ОС
  os: String!

  # Браузер
  browser: String!

  # IP адрес
  ip: String!

  # Действие
  action: String!
  action_type: KycTimelineActionType!

  # Тег
  tag: String!

  # Мембер
  creator: Members

  # Документ
  document: ApplicantDocument

  # ID аппликанта
  applicant_id: ID!

  # Тип аппликанта
  applicant_type: ApplicantType!

  # Аппликант
  applicant: Client

  # Компания
  company: Company

  # Старые значения
  action_old_value: JSON

  # Новые значения
  action_new_value: JSON

  # Дата добавления
  created_at: DateTimeUtc!
}

enum KycTimelineActionType {
  DOCUMENT_UPLOAD
  DOCUMENT_STATE
  VERIFICATION
  EMAIL
  PROFILE
}

# Order by clause for Query.kycTimelines.orderBy.
input QueryKycTimelinesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryKycTimelinesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.kycTimelines.orderBy.
enum QueryKycTimelinesOrderByColumn {
  ID
  CREATED_AT
}

type KycTimelines {
  data: [KycTimeline!]
  paginatorInfo: PaginatorInfo
}

type MemberProfile {
  id: ID!

  # Имя участника
  first_name: String

  # Фамилия участника
  last_name: String

  # Email участника
  email: EMAIL

  # Пол участника
  sex: Sex

  # Активен = true или не активный = false участник
  is_active: Boolean

  # Последняя авторизация
  last_login_at: DateTimeUtc

  # получить компанию участника
  company: Company!

  # получить страну участника
  country: Country

  # Получить язык участника
  language: Languages

  # Получить группу участника
  group: GroupRole

  # Получить должность
  position: DepartmentPosition

  # Получить департамент
  department: Department

  # ID настройки двухфактороной авторизации
  two_factor_auth_setting_id: ID

  # Получить настройки двухфакторной авторизации
  two_factor_auth_settings: TwoFactorAuthSettings

  # Дополнительны поля
  additional_fields: JSON

  # Дополнительны поля для member info
  additional_info_fields: JSON

  # Полное имя
  fullname: String

  # Access limitation groups
  access_groups: [MemberAccessLimitation]

  # если true видит только своих аппликантов
  is_show_owner_applicants: Boolean

  # Security PIN
  security_pin: String

  # Google Secret
  google2fa_secret: String

  # Member Backup Codes
  backup_codes: JSON

  # Подписывать или нет транзакцию
  is_sign_transaction: Boolean

  # Member ip address
  ip_addresses: [ClientIpAddress]
}

# Dynamic WHERE conditions for the `where` argument on the query `modules`.
input QueryModulesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryModulesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryModulesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryModulesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryModulesWhereWhereConditionsRelation
}

# Allowed column names for Query.modules.where.
enum QueryModulesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `modules`.
input QueryModulesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryModulesWhereWhereConditions
}

# Order by clause for Query.modules.orderBy.
input QueryModulesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryModulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.modules.orderBy.
enum QueryModulesOrderByColumn {
  ID
}

# Dynamic WHERE conditions for the `where` argument on the query `modulesWithKyc`.
input QueryModulesWithKycWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryModulesWithKycWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryModulesWithKycWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryModulesWithKycWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryModulesWithKycWhereWhereConditionsRelation
}

# Allowed column names for Query.modulesWithKyc.where.
enum QueryModulesWithKycWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `modulesWithKyc`.
input QueryModulesWithKycWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryModulesWithKycWhereWhereConditions
}

# Order by clause for Query.modulesWithKyc.orderBy.
input QueryModulesWithKycOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryModulesWithKycOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.modulesWithKyc.orderBy.
enum QueryModulesWithKycOrderByColumn {
  ID
}

# Dynamic WHERE conditions for the `filter` argument on the query `operationTypes`.
input QueryOperationTypesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryOperationTypesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryOperationTypesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryOperationTypesFilterFilterConditions!]
}

# Column names for Query.operationTypes.filter.
enum QueryOperationTypesFilterStatic {
  FEE_TYPE_ID
  TRANSFER_TYPE
  PAYMENT_SYSTEM_ID
}

# Dynamic WHERE conditions for the `filter` argument on the query `paymentStatuses`.
input QueryPaymentStatusesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentStatusesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentStatusesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentStatusesFilterFilterConditions!]
}

# Column names for Query.paymentStatuses.filter.
enum QueryPaymentStatusesFilterStatic {
  OPERATION_TYPE
}

type Sender {
  # Sender name
  sender_name: String!
}

# Платежи
# Banking -> Payments List
type Payments {
  id: ID!

  # Получить связанный аккаунт
  account: Account

  # Получить связанную валюту
  currency: Currencies
  price_list_fees: PriceListFee

  # Номер счета или IBAN получателя
  recipient_account: String
  recipient_bank_name: String
  recipient_bank_address: String
  recipient_bank_swift: String
  recipient_bank_country: Country
  beneficiary_name: String
  beneficiary_state: String
  beneficiary_country: Country
  beneficiary_address: String
  beneficiary_city: String
  beneficiary_zip: String
  beneficiary_additional_data: JSON

  # Сумма
  amount: Decimal!
  amount_real: Decimal!
  status_id: ID

  # Комиссия
  fee: Decimal
  fee_type: FeeType

  # Получить связанного мембера
  member: Members

  # Получить связанную компанию
  company: Company

  # Получить связанныую срочность
  payment_urgency: PaymentUrgency

  # Статус
  status: PaymentStatus

  # Получить связанный тип
  payment_operation_type: OperationType

  # Получить связанный провайдер
  payment_provider: PaymentProvider

  # Номер платежа
  payment_number: String
  received_at: DateTimeUtc
  created_at: DateTimeUtc
  updated_at: DateTimeUtc

  # Дата и время выполнения транзакции
  execution_at: DateTimeUtc
  respondent_fee: RespondentFee
  error: String
}

# Dynamic WHERE conditions for the `where` argument on the query `permissions`.
input QueryPermissionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryPermissionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPermissionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPermissionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryPermissionsWhereWhereConditionsRelation
}

# Allowed column names for Query.permissions.where.
enum QueryPermissionsWhereColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `permissions`.
input QueryPermissionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryPermissionsWhereWhereConditions
}

# Dynamic WHERE conditions for the `filter` argument on the query `priceListFees`.
input QueryPriceListFeesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPriceListFeesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPriceListFeesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPriceListFeesFilterFilterConditions!]
}

# Column names for Query.priceListFees.filter.
enum QueryPriceListFeesFilterStatic {
  ID
  PRICE_LIST_ID
  TYPE_ID
  OPERATION_TYPE_ID
  PERIOD_ID
  HAS_COMPANY_FILTER_BY_ID
  HAS_PAYMENT_PROVIDER_FILTER_BY_ID
  HAS_PAYMENT_SYSTEM_FILTER_BY_ID
  HAS_FEES_FILTER_BY_ID
}

type ProjectApiSettingPassword {
  # ID
  id: ID!

  # Пароль
  password: String!
}

# Реквизиты
# Banking -> Account -> Requisites
type Requisite {
  # ACCOUNT ID
  id: ID

  # Создатель
  owner: ApplicantIndividual

  # Связанный банк
  bank: PaymentBank

  # IBAN
  account_number: String

  # Currency
  currency: Currencies
}

# Dynamic WHERE conditions for the `filter` argument on the query `requisites`.
input QueryRequisitesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryRequisitesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRequisitesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRequisitesFilterFilterConditions!]
}

# Column names for Query.requisites.filter.
enum QueryRequisitesFilterStatic {
  COMPANY_ID
  PAYMENT_PROVIDER_ID
  PAYMENT_SYSTEM_ID
  PAYMENT_BANK_ID
  ACCOUNT_NUMBER
}

type StatusType {
  status: String!
  message: String
}

# Комментарии билетов
type TicketComments {
  id: ID!

  # Сообщение
  message: String!

  # Получить файл
  file_object: Files

  # Получить билет
  ticket: Ticket

  # Получить Клиента
  client: ApplicantIndividual
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

# Билеты
# Banking -> Tickets
type Ticket {
  id: ID!

  # Название
  title: String!

  # Сообщение
  message: String!

  # Статус
  status: TicketStatus

  # Получить файл
  file_object: Files

  # Получить компанию
  company: Company

  # Получить позицию
  position: DepartmentPosition

  # Получить Департаменты
  department: Department

  # Получить мембера
  member: Members

  # Получить Клиента
  client: ApplicantIndividual

  # Получить комментарии
  comments: [TicketComments]
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

type TicketStatus {
  id: ID!
  name: String!
}

# Исходящие переводы
type TransferIncoming {
  id: ID!

  # Сумма
  amount: Decimal!
  amount_debt: Decimal!

  # Коммиссия
  fee: Fee

  # Все коммиссии
  fees: [Fee]

  # Файлы
  files: [Files]

  # Получить связанную валюту
  currency: Currencies

  # Статус
  status: PaymentStatus

  # Получить связанную срочность
  payment_urgency: PaymentUrgency

  # Получить связанный тип
  payment_operation_type: OperationType

  # Получить связанный провайдер
  payment_provider: PaymentProvider

  # Получить связанную информацию по провайдеру
  payment_provider_history: PaymentProviderHistory

  # Получить связанную платежную систему
  payment_system: PaymentSystem

  # Получить связанный банк
  payment_bank: PaymentBank

  # Номер платежа
  payment_number: String!

  # Получить связанный тип трансфера
  transfer_type: TypeOfTransfer

  # Получить связанный аккаунт
  account: Account

  # Получатьль платежа (Индивидуал или Компани)
  recipient: Client

  # Получить связанную компанию
  company: Company
  system_message: String
  reason: String
  channel: String
  bank_message: String

  # Номер счета или IBAN отправителя
  sender_account: String
  sender_bank_name: String
  sender_bank_address: String
  sender_bank_swift: String
  sender_bank_country: Country
  sender_name: String
  sender_country: Country
  sender_city: String
  sender_address: String
  sender_state: String
  sender_zip: String
  respondent_fee: RespondentFee

  # Дата и время выполнения транзакции
  execution_at: DateTimeUtc
  created_at: DateTimeUtc
  updated_at: DateTimeUtc
}

type TransferIncomingStatistic {
  status_id: ID!
  name: String!
  count: Int!
}

type TransferOutgoingStatistic {
  status_id: ID!
  name: String!
  count: Int!
}

type userAuthResponse {
  data: Users
  permissions: PermissionAuth!
}

# Пользователи
# Roles->Users
type Users {
  id: ID

  # Имя участника
  first_name: String

  # Фамилия участника
  last_name: String

  # Email участника
  email: EMAIL

  # получить компанию
  company: Company

  # Получить группу
  group: GroupRole

  # Полное имя
  fullname: String
}

# PermissionAuth
type PermissionAuth {
  PERMISSION_TICKETS: [PERMISSION_TICKETS!]!
  PERMISSION_DASHBOARD: [PERMISSION_DASHBOARD!]!
  PERMISSION_MY_NET_WORTH: [PERMISSION_MY_NET_WORTH!]!
  PERMISSION_ACCOUNT_DETAILS: [PERMISSION_ACCOUNT_DETAILS!]!
  PERMISSION_MAKE_PAYMENTS: [PERMISSION_MAKE_PAYMENTS!]!
  PERMISSION_REQUISITES: [PERMISSION_REQUISITES!]!
  PERMISSION_MY_TEMPLATES: [PERMISSION_MY_TEMPLATES!]!
  PERMISSION_STATEMENTS: [PERMISSION_STATEMENTS!]!
  PERMISSION_PAYMENT_LIST: [PERMISSION_PAYMENT_LIST!]!
  PERMISSION_PAYMENT_DETAILS: [PERMISSION_PAYMENT_DETAILS!]!
  PERMISSION_SETTINGS_CONTACT_DETAILS: [PERMISSION_SETTINGS_CONTACT_DETAILS!]!
  PERMISSION_SETTINGS_LOG_IN_DETAILS: [PERMISSION_SETTINGS_LOG_IN_DETAILS!]!
  PERMISSION_SETTINGS_SECURITY_LEVEL: [PERMISSION_SETTINGS_SECURITY_LEVEL!]!
  PERMISSION_SETTINGS_ACCOUNT: [PERMISSION_SETTINGS_ACCOUNT!]!
}

# Permission list name Tickets
enum PERMISSION_TICKETS {
  READ
  NEW_TICKET
  CLOSE_TICKET
  STATUS_REPLY_REQUIRED
  STATUS_OPENED
  STATUS_CLOSED
  STATUS_NO_REPLY_REQUIRED
}

# Permission list name Dashboard
enum PERMISSION_DASHBOARD {
  YES
  FEEDBACK
  INVITE_FRIENDS
  LAST_PAYMENTS
}

# Permission list name My Net Worth
enum PERMISSION_MY_NET_WORTH {
  YES
  SUMMARY
  ASSETS
  LIABILITIES
}

# Permission list name Account Details
enum PERMISSION_ACCOUNT_DETAILS {
  READ
  EDIT
  SHOW_BALANCE
  SHOW_PROVIDER_INFO
  STATUS_PENDING
  STATUS_ACTIVE
  WAITING_FOR_I_B_A_N_ACTIVATION
  STATUS_CLOSED
  STATUS_SUSPENDED
}

# Permission list name Make Payments
enum PERMISSION_MAKE_PAYMENTS {
  CREATE_PAYMENTS
  SIGN_PAYMENTS
}

# Permission list name Requisites
enum PERMISSION_REQUISITES {
  READ
  DOWNLOAD_REQUISITES
  SEND_REQUISITES_DETAILS
}

# Permission list name My Templates
enum PERMISSION_MY_TEMPLATES {
  READ
  EDIT
  DELETE
  ADD_NEW
}

# Permission list name Statements
enum PERMISSION_STATEMENTS {
  READ
  EXPORT_STATEMENT
}

# Permission list name Payment List
enum PERMISSION_PAYMENT_LIST {
  READ
  EDIT
  CANCEL_PAYMENT
}

# Permission list name Payment Details
enum PERMISSION_PAYMENT_DETAILS {
  READ
  EXPORT_PAYMENT_DETAILS
}

# Permission list name Settings:Contact Details
enum PERMISSION_SETTINGS_CONTACT_DETAILS {
  READ
  EDIT
}

# Permission list name Settings:Log in Details
enum PERMISSION_SETTINGS_LOG_IN_DETAILS {
  READ
  EDIT
  MY_DEVICE
  TWO_FACTOR_AUTHENTICATION
  SECURE_PIN
}

# Permission list name Settings:Security Level
enum PERMISSION_SETTINGS_SECURITY_LEVEL {
  READ
  EDIT
}

# Permission list name Settings:Account
enum PERMISSION_SETTINGS_ACCOUNT {
  READ
  EDIT
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantAccounts`.
input QueryApplicantAccountsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantAccountsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantAccountsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantAccountsFilterFilterConditions!]
}

# Column names for Query.applicantAccounts.filter.
enum QueryApplicantAccountsFilterStatic {
  IS_SHOW
}

# Order by clause for Query.applicantAccounts.orderBy.
input QueryApplicantAccountsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantAccountsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantAccounts.orderBy.
enum QueryApplicantAccountsOrderByColumn {
  ID
  CURRENT_BALANCE
}

type ApplicantAccount {
  # ID
  id: ID!

  # Получить связанный код валюты
  currency: Currencies

  # Аккаунт/Карта
  account_number: String

  # Тип аккаунта
  account_type: String!

  # Имя
  account_name: String!

  # Баланс
  current_balance: Decimal

  # Показать на главной
  is_show: Boolean

  # Первичный аккаунт
  is_primary: Boolean
}

type ApplicantDevice {
  # ID
  id: ID

  # IP
  ip: String

  # Платформа
  platform: String

  # Браузер
  browser: String

  # Устройство
  device_type: String

  # Модель
  model: String

  # Доверенное устройство
  trusted: Boolean!

  # Дата истечения
  expired_at: DateTimeUtc

  # Дата создания
  created_at: DateTimeUtc!
}

type ApplicantProfile {
  id: ID!

  # Имя
  first_name: String

  # Фамилия
  last_name: String

  # Отчество
  middle_name: String

  # email
  email: EMAIL

  # Адрес сайта
  url: String

  # Телефон
  phone: String

  # Верецифиорован телефон true/false
  is_verification_phone: Boolean

  # Получить связанную страну
  country: Country

  # Получить язык
  language: Languages

  # Получить связанную страну гражданства
  citizenship_country: Country

  # Штат / область
  state: String

  # Город
  city: String

  # Адрес
  address: String

  # Индекс
  zip: String

  # Национальность
  nationality: String

  # Получить связанную страну рождения
  birth_country: Country

  # Штат/область рождения
  birth_state: String

  # Город рождения
  birth_city: String

  # Дата рождения
  birth_at: Date

  # Пол
  sex: Sex

  # Время создания
  created_at: DateTimeUtc

  # Дополнительные поля Profile data
  profile_additional_fields: JSON

  # Дополнительные поля для Personal info
  personal_additional_fields: JSON

  # Дополнительные поля блока контакты
  contacts_additional_fields: JSON

  # Полное имя
  fullname: String

  # Получить статусы
  status: ApplicantStatus

  # Получить состояния
  applicant_state: ApplicantState

  # Получить причины
  state_reason: ApplicantStateReason

  # Получить уровни рисков
  risk_level: ApplicantRiskLevel

  # Получить менеджера
  manager: Members

  # Получить метки
  labels: [ApplicantIndividualLabel]

  # Название компании держателя applicant
  company: Company

  # Получить заметки
  notes: [ApplicantIndividualNotes]

  # Получить модули
  modules: [ApplicantIndividualModules]

  # Получить компании
  companies: [ApplicantCompany]

  # Получить группу
  group: GroupRole

  # Фото
  photo: Files

  # Оповещения об устройствах на email
  notify_device_email: Boolean

  # Получить two factor auth
  two_factor_auth: TwoFactorAuthSettings

  # Security PIN
  security_pin: String

  # Google Secret
  google2fa_secret: String

  # Backup Codes
  backup_codes: JSON

  # IP адрес
  ip_addresses: [ClientIpAddress]
}

type ApplicantDetailsRequisites {
  currency: String!
  beneficiary: String!
  address: String!
  country: String!
  iban: String!
  bank_name: String!
  swift_code: String!
  bank_address: String!
  bank_country: String!
}

# Реквизиты
type ApplicantRequisites {
  # Account ID
  id: ID!

  # IBAN
  account_number: String!

  # Создатель
  owner: ApplicantProfile

  # Связанный банк
  bank: PaymentBank

  # Валюта
  currency: Currencies
}

# A paginated list of Languages items.
type LanguagesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Languages items.
  data: [Languages!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `accountLimits`.
input QueryAccountLimitsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryAccountLimitsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountLimitsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountLimitsFilterFilterConditions!]
}

# Column names for Query.accountLimits.filter.
enum QueryAccountLimitsFilterStatic {
  HAS_CURRENCY_MIXED_ID_OR_NAME
  HAS_COMMISSION_TEMPLATE_LIMIT_TYPE_MIXED_ID_OR_NAME
  HAS_COMMISSION_TEMPLATE_LIMIT_TRANSFER_DIRECTION_MIXED_ID_OR_NAME
  HAS_COMMISSION_TEMPLATE_LIMIT_PERIOD_MIXED_ID_OR_NAME
  HAS_COMMISSION_TEMPLATE_LIMIT_ACTION_TYPE_MIXED_ID_OR_NAME
  ACCOUNT_ID
  PERIOD_COUNT
}

# Order by clause for Query.accountLimits.orderBy.
input QueryAccountLimitsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountLimitsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountLimits.orderBy.
enum QueryAccountLimitsOrderByColumn {
  ID
}

# A paginated list of AccountLimit items.
type AccountLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AccountLimit items.
  data: [AccountLimit!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryAccountReachedLimitsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountReachedLimitsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountReachedLimitsFilterFilterConditions!]
}

# Column names for Query.accountReachedLimits.filter.
enum QueryAccountReachedLimitsFilterStatic {
  ACCOUNT_ID
  LIMIT_CURRENCY
  LIMIT_TYPE
  LIMIT_VALUE
  TRANSFER_DIRECTION
  PERIOD
  AMOUNT
}

# Dynamic WHERE conditions for the `hasAccount` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsHasAccountWhereHasConditions {
  # The column that is used for the condition.
  column: QueryAccountReachedLimitsHasAccountColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountReachedLimitsHasAccountWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountReachedLimitsHasAccountWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountReachedLimitsHasAccountWhereHasConditionsRelation
}

# Allowed column names for Query.accountReachedLimits.hasAccount.
enum QueryAccountReachedLimitsHasAccountColumn {
  ID
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `hasAccount` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsHasAccountWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountReachedLimitsHasAccountWhereHasConditions
}

# Dynamic WHERE conditions for the `where` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryAccountReachedLimitsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountReachedLimitsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountReachedLimitsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryAccountReachedLimitsWhereWhereConditionsRelation
}

# Allowed column names for Query.accountReachedLimits.where.
enum QueryAccountReachedLimitsWhereColumn {
  ACCOUNT_ID
  GROUP_TYPE
  CLIENT_NAME
  CLIENT_TYPE
  TRANSFER_DIRECTION
  LIMIT_TYPE
  LIMIT_VALUE
  LIMIT_CURRENCY
  PERIOD
  AMOUNT
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `accountReachedLimits`.
input QueryAccountReachedLimitsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryAccountReachedLimitsWhereWhereConditions
}

# Order by clause for Query.accountReachedLimits.orderBy.
input QueryAccountReachedLimitsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountReachedLimitsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountReachedLimits.orderBy.
enum QueryAccountReachedLimitsOrderByColumn {
  ID
}

# A paginated list of AccountReachedLimit items.
type AccountReachedLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AccountReachedLimit items.
  data: [AccountReachedLimit!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `accountList`.
input QueryAccountListFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryAccountListFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryAccountListFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryAccountListFilterFilterConditions!]
}

# Column names for Query.accountList.filter.
enum QueryAccountListFilterStatic {
  HAS_COMPANY_MIXED_ID_OR_NAME
  HAS_PAYMENT_PROVIDER_MIXED_ID_OR_NAME
  HAS_PAYMENT_SYSTEM_MIXED_ID_OR_NAME
  HAS_OWNER_MIXED_ID_OR_FULLNAME
  MIXED_ACCOUNT_NUMBER_OR_ACCOUNT_NAME
  CURRENCY_ID
  HAS_GROUP_ROLE_MIXED_ID_OR_NAME
  GROUP_TYPE_ID
  HAS_MEMBER_MIXED_ID_OR_FULLNAME
  IS_PRIMARY
  HAS_COMMISSION_TEMPLATE_MIXED_ID_OR_FULLNAME
  ACCOUNT_STATE_ID
  HAS_CLIENTABLE_MIXED_ID_OR_FULLNAME
}

# Order by clause for Query.accountList.orderBy.
input QueryAccountListOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryAccountListOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.accountList.orderBy.
enum QueryAccountListOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of Account items.
type AccountPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Account items.
  data: [Account!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantIndividuals`.
input QueryApplicantIndividualsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualsFilterFilterConditions!]
}

# Column names for Query.applicantIndividuals.filter.
enum QueryApplicantIndividualsFilterStatic {
  ID
  FULLNAME
  EMAIL
  COMPANY_ID
  PROJECT_ID
  KYC_LEVEL_ID
  HAS_RISK_LEVEL_FILTER_BY_ID
  HAS_STATE_REASON_FILTER_BY_ID
  HAS_STATUS_FILTER_BY_ID
  HAS_GROUP_ROLE_MIXED_ID_OR_NAME
  HAS_MODULES_FILTER_BY_ID
}

enum Sort {
  ASC
  DESC
}

# Order by clause for Query.applicantIndividuals.orderBy.
input QueryApplicantIndividualsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividuals.orderBy.
enum QueryApplicantIndividualsOrderByColumn {
  ID
  FIRST_NAME
  LAST_NAME
  EMAIL
  CREATED_AT
  FULLNAME
  COMPANY_ID
}

# A paginated list of ApplicantIndividual items.
type ApplicantIndividualPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividual items.
  data: [ApplicantIndividual!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesFilterFilterConditions!]
}

# Column names for Query.applicantCompanies.filter.
enum QueryApplicantCompaniesFilterStatic {
  ID
  COMPANY_ID
  PROJECT_ID
  ACCOUNT_MANAGER_MEMBER_ID
  HAS_STATE_REASON_MIXED_ID_OR_NAME
  HAS_GROUP_ROLE_MIXED_ID_OR_NAME
  HAS_RISK_LEVEL_MIXED_ID_OR_NAME
  HAS_STATUS_MIXED_ID_OR_NAME
  HAS_BUSINESS_TYPE_MIXED_ID_OR_NAME
  HAS_OWNER_MIXED_ID_OR_FULLNAME
  HAS_KYC_LEVEL_MIXED_ID_OR_NAME
  HAS_STATUS_FILTER_BY_ID
  HAS_MODULES_FILTER_BY_ID
  NAME
  URL
  EMAIL
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanies.where.
enum QueryApplicantCompaniesWhereColumn {
  ID
  ACCOUNT_MANAGER_MEMBER_ID
  APPLICANT_STATE_ID
  APPLICANT_STATE_REASON_ID
  NAME
  URL
  EMAIL
  CREATED_AT
  GROUP_ID
  COMPANY_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesWhereWhereConditions
}

# Dynamic WHERE conditions for the `hasGroupRole` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasGroupRoleWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasGroupRoleColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasGroupRoleWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasGroupRoleWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasGroupRoleWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasGroupRole.
enum QueryApplicantCompaniesHasGroupRoleColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasGroupRole` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasGroupRoleWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasGroupRoleWhereHasConditions
}

# Dynamic WHERE conditions for the `hasRiskLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasRiskLevelWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasRiskLevelColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasRiskLevelWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasRiskLevelWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasRiskLevelWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasRiskLevel.
enum QueryApplicantCompaniesHasRiskLevelColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasRiskLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasRiskLevelWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasRiskLevelWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStateReason` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStateReasonWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasStateReasonColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasStateReasonWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasStateReasonWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasStateReasonWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasStateReason.
enum QueryApplicantCompaniesHasStateReasonColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStateReason` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStateReasonWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasStateReasonWhereHasConditions
}

# Dynamic WHERE conditions for the `hasStatus` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStatusWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasStatusColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasStatusWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasStatusWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasStatusWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasStatus.
enum QueryApplicantCompaniesHasStatusColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasStatus` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasStatusWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasStatusWhereHasConditions
}

# Dynamic WHERE conditions for the `hasBusinessType` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasBusinessTypeWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasBusinessTypeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasBusinessTypeWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasBusinessTypeWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasBusinessTypeWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasBusinessType.
enum QueryApplicantCompaniesHasBusinessTypeColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasBusinessType` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasBusinessTypeWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasBusinessTypeWhereHasConditions
}

# Dynamic WHERE conditions for the `hasOwner` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasOwnerWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasOwnerColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasOwnerWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasOwnerWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasOwnerWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasOwner.
enum QueryApplicantCompaniesHasOwnerColumn {
  FULLNAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasOwner` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasOwnerWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasOwnerWhereHasConditions
}

# Dynamic WHERE conditions for the `hasKycLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasKycLevelWhereHasConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompaniesHasKycLevelColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompaniesHasKycLevelWhereHasConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompaniesHasKycLevelWhereHasConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompaniesHasKycLevelWhereHasConditionsRelation
}

# Allowed column names for Query.applicantCompanies.hasKycLevel.
enum QueryApplicantCompaniesHasKycLevelColumn {
  NAME
  ID
}

# Dynamic HAS conditions for WHERE conditions for the `hasKycLevel` argument on the query `applicantCompanies`.
input QueryApplicantCompaniesHasKycLevelWhereHasConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompaniesHasKycLevelWhereHasConditions
}

# Order by clause for Query.applicantCompanies.orderBy.
input QueryApplicantCompaniesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompaniesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanies.orderBy.
enum QueryApplicantCompaniesOrderByColumn {
  ID
  NAME
  EMAIL
  CREATED_AT
  URL
  OWNER_ID
  COMPANY_ID
}

# A paginated list of ApplicantCompany items.
type ApplicantCompanyPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompany items.
  data: [ApplicantCompany!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyBusinessType`.
input QueryApplicantCompanyBusinessTypeWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyBusinessTypeWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyBusinessTypeWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyBusinessTypeWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyBusinessTypeWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyBusinessType.where.
enum QueryApplicantCompanyBusinessTypeWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyBusinessType`.
input QueryApplicantCompanyBusinessTypeWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyBusinessTypeWhereWhereConditions
}

# Order by clause for Query.applicantCompanyBusinessType.orderBy.
input QueryApplicantCompanyBusinessTypeOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyBusinessTypeOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyBusinessType.orderBy.
enum QueryApplicantCompanyBusinessTypeOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantCompanyBusinessType items.
type ApplicantCompanyBusinessTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyBusinessType items.
  data: [ApplicantCompanyBusinessType!]!
}

# Order by clause for Query.applicantCompanyLabelsAvailable.orderBy.
input QueryApplicantCompanyLabelsAvailableOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyLabelsAvailableOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyLabelsAvailable.orderBy.
enum QueryApplicantCompanyLabelsAvailableOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantCompanyLabel items.
type ApplicantCompanyLabelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyLabel items.
  data: [ApplicantCompanyLabel!]!
}

# Order by clause for Query.applicantCompanyNotes.orderBy.
input QueryApplicantCompanyNotesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyNotesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyNotes.orderBy.
enum QueryApplicantCompanyNotesOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantCompanyNotes items.
type ApplicantCompanyNotesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyNotes items.
  data: [ApplicantCompanyNotes!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantCompanyRiskLevelHistory`.
input QueryApplicantCompanyRiskLevelHistoryFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyRiskLevelHistoryFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyRiskLevelHistoryFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyRiskLevelHistoryFilterFilterConditions!]
}

# Column names for Query.applicantCompanyRiskLevelHistory.filter.
enum QueryApplicantCompanyRiskLevelHistoryFilterStatic {
  APPLICANT_COMPANY_ID
  RISK_LEVEL_ID
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantCompanyRiskLevelHistory`.
input QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantCompanyRiskLevelHistoryWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantCompanyRiskLevelHistory.where.
enum QueryApplicantCompanyRiskLevelHistoryWhereColumn {
  RISK_LEVEL_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantCompanyRiskLevelHistory`.
input QueryApplicantCompanyRiskLevelHistoryWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantCompanyRiskLevelHistoryWhereWhereConditions
}

# Order by clause for Query.applicantCompanyRiskLevelHistory.orderBy.
input QueryApplicantCompanyRiskLevelHistoryOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantCompanyRiskLevelHistoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantCompanyRiskLevelHistory.orderBy.
enum QueryApplicantCompanyRiskLevelHistoryOrderByColumn {
  ID
}

# A paginated list of ApplicantCompanyRiskLevelHistory items.
type ApplicantCompanyRiskLevelHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantCompanyRiskLevelHistory items.
  data: [ApplicantCompanyRiskLevelHistory!]!
}

# История уровней риска Applicant Company
# Applicants -> Individual -> Individual Company Full Profile -> General
type ApplicantCompanyRiskLevelHistory {
  id: ID!

  # Комментарий
  comment: String!

  # Дата создания сообщения
  created_at: DateTimeUtc

  # Получить аппликанта
  applicant_company: ApplicantCompany

  # Получить владельца
  manager: Members

  # Получить уровень риска
  risk_level: ApplicantRiskLevel
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantDocuments`.
input QueryApplicantDocumentsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantDocumentsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantDocumentsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantDocumentsFilterFilterConditions!]
}

# Column names for Query.applicantDocuments.filter.
enum QueryApplicantDocumentsFilterStatic {
  ID
  APPLICANT_ID
  DOCUMENT_TYPE_ID
  DOCUMENT_STATE_ID
}

# Order by clause for Query.applicantDocuments.orderBy.
input QueryApplicantDocumentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantDocumentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantDocuments.orderBy.
enum QueryApplicantDocumentsOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantDocument items.
type ApplicantDocumentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantDocument items.
  data: [ApplicantDocument!]!
}

# A paginated list of ApplicantDocumentInternalNote items.
type ApplicantDocumentInternalNotePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantDocumentInternalNote items.
  data: [ApplicantDocumentInternalNote!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantDocumentTags`.
input QueryApplicantDocumentTagsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantDocumentTagsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantDocumentTagsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantDocumentTagsFilterFilterConditions!]
}

# Column names for Query.applicantDocumentTags.filter.
enum QueryApplicantDocumentTagsFilterStatic {
  NAME
  HAS_CATEGORY_FILTER_BY_NAME
}

# Order by clause for Query.applicantDocumentTags.orderBy.
input QueryApplicantDocumentTagsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantDocumentTagsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantDocumentTags.orderBy.
enum QueryApplicantDocumentTagsOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantDocumentTag items.
type ApplicantDocumentTagPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantDocumentTag items.
  data: [ApplicantDocumentTag!]!
}

# A paginated list of ApplicantDocumentTagCategory items.
type ApplicantDocumentTagCategoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantDocumentTagCategory items.
  data: [ApplicantDocumentTagCategory!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantIndividualCompanyPositions`.
input QueryApplicantIndividualCompanyPositionsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualCompanyPositionsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualCompanyPositionsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualCompanyPositionsFilterFilterConditions!]
}

# Column names for Query.applicantIndividualCompanyPositions.filter.
enum QueryApplicantIndividualCompanyPositionsFilterStatic {
  NAME
  COMPANY_ID
}

# Order by clause for Query.applicantIndividualCompanyPositions.orderBy.
input QueryApplicantIndividualCompanyPositionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualCompanyPositionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualCompanyPositions.orderBy.
enum QueryApplicantIndividualCompanyPositionsOrderByColumn {
  ID
  NAME
  COMPANY_ID
}

# A paginated list of ApplicantIndividualCompanyPosition items.
type ApplicantIndividualCompanyPositionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualCompanyPosition items.
  data: [ApplicantIndividualCompanyPosition!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `applicantIndividualCompanyRelations`.
input QueryApplicantIndividualCompanyRelationsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryApplicantIndividualCompanyRelationsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantIndividualCompanyRelationsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantIndividualCompanyRelationsFilterFilterConditions!]
}

# Column names for Query.applicantIndividualCompanyRelations.filter.
enum QueryApplicantIndividualCompanyRelationsFilterStatic {
  NAME
  COMPANY_ID
}

# Order by clause for Query.applicantIndividualCompanyRelations.orderBy.
input QueryApplicantIndividualCompanyRelationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualCompanyRelationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualCompanyRelations.orderBy.
enum QueryApplicantIndividualCompanyRelationsOrderByColumn {
  ID
  NAME
  COMPANY_ID
}

# A paginated list of ApplicantIndividualCompanyRelation items.
type ApplicantIndividualCompanyRelationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualCompanyRelation items.
  data: [ApplicantIndividualCompanyRelation!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantRiskLevelHistory`.
input QueryApplicantRiskLevelHistoryWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantRiskLevelHistoryWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantRiskLevelHistoryWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantRiskLevelHistoryWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantRiskLevelHistoryWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantRiskLevelHistory.where.
enum QueryApplicantRiskLevelHistoryWhereColumn {
  RISK_LEVEL_ID
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantRiskLevelHistory`.
input QueryApplicantRiskLevelHistoryWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantRiskLevelHistoryWhereWhereConditions
}

# Order by clause for Query.applicantRiskLevelHistory.orderBy.
input QueryApplicantRiskLevelHistoryOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantRiskLevelHistoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantRiskLevelHistory.orderBy.
enum QueryApplicantRiskLevelHistoryOrderByColumn {
  ID
}

# A paginated list of ApplicantRiskLevelHistory items.
type ApplicantRiskLevelHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantRiskLevelHistory items.
  data: [ApplicantRiskLevelHistory!]!
}

# История уровней риска Applicant Individual
# Applicants -> Individual -> Individual Full Profile -> General
type ApplicantRiskLevelHistory {
  id: ID!

  # Комментарий
  comment: String!

  # Дата создания сообщения
  created_at: DateTimeUtc

  # Получить аппликанта
  applicant: ApplicantIndividual

  # Получить владельца
  manager: Members

  # Получить уровень риска
  risk_level: ApplicantRiskLevel
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantKycLevels`.
input QueryApplicantKycLevelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantKycLevelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantKycLevelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantKycLevelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantKycLevelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantKycLevels.where.
enum QueryApplicantKycLevelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantKycLevels`.
input QueryApplicantKycLevelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantKycLevelsWhereWhereConditions
}

# Order by clause for Query.applicantKycLevels.orderBy.
input QueryApplicantKycLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantKycLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantKycLevels.orderBy.
enum QueryApplicantKycLevelsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantKycLevel items.
type ApplicantKycLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantKycLevel items.
  data: [ApplicantKycLevel!]!
}

# Order by clause for Query.applicantIndividualLabelsAvailable.orderBy.
input QueryApplicantIndividualLabelsAvailableOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualLabelsAvailableOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualLabelsAvailable.orderBy.
enum QueryApplicantIndividualLabelsAvailableOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantIndividualLabel items.
type ApplicantIndividualLabelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualLabel items.
  data: [ApplicantIndividualLabel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicant_modules`.
input QueryApplicantModulesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantModulesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantModulesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantModulesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantModulesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicant_modules.where.
enum QueryApplicantModulesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicant_modules`.
input QueryApplicantModulesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantModulesWhereWhereConditions
}

# Order by clause for Query.applicant_modules.orderBy.
input QueryApplicantModulesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantModulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicant_modules.orderBy.
enum QueryApplicantModulesOrderByColumn {
  ID
}

# A paginated list of ApplicantModules items.
type ApplicantModulesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantModules items.
  data: [ApplicantModules!]!
}

# Order by clause for Query.applicantIndividualNotes.orderBy.
input QueryApplicantIndividualNotesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantIndividualNotesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantIndividualNotes.orderBy.
enum QueryApplicantIndividualNotesOrderByColumn {
  ID
  CREATED_AT
}

# A paginated list of ApplicantIndividualNotes items.
type ApplicantIndividualNotesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantIndividualNotes items.
  data: [ApplicantIndividualNotes!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantRiskLevels`.
input QueryApplicantRiskLevelsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantRiskLevelsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantRiskLevelsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantRiskLevelsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantRiskLevelsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantRiskLevels.where.
enum QueryApplicantRiskLevelsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantRiskLevels`.
input QueryApplicantRiskLevelsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantRiskLevelsWhereWhereConditions
}

# Order by clause for Query.applicantRiskLevels.orderBy.
input QueryApplicantRiskLevelsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantRiskLevelsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantRiskLevels.orderBy.
enum QueryApplicantRiskLevelsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantRiskLevel items.
type ApplicantRiskLevelPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantRiskLevel items.
  data: [ApplicantRiskLevel!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStates`.
input QueryApplicantStatesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStatesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStatesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStates.where.
enum QueryApplicantStatesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStates`.
input QueryApplicantStatesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStatesWhereWhereConditions
}

# Order by clause for Query.applicantStates.orderBy.
input QueryApplicantStatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStates.orderBy.
enum QueryApplicantStatesOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantState items.
type ApplicantStatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantState items.
  data: [ApplicantState!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStateReasons`.
input QueryApplicantStateReasonsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStateReasonsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStateReasonsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStateReasonsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStateReasonsWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStateReasons.where.
enum QueryApplicantStateReasonsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStateReasons`.
input QueryApplicantStateReasonsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStateReasonsWhereWhereConditions
}

# Order by clause for Query.applicantStateReasons.orderBy.
input QueryApplicantStateReasonsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStateReasonsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStateReasons.orderBy.
enum QueryApplicantStateReasonsOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantStateReason items.
type ApplicantStateReasonPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantStateReason items.
  data: [ApplicantStateReason!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `applicantStatuses`.
input QueryApplicantStatusesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryApplicantStatusesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryApplicantStatusesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryApplicantStatusesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryApplicantStatusesWhereWhereConditionsRelation
}

# Allowed column names for Query.applicantStatuses.where.
enum QueryApplicantStatusesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `applicantStatuses`.
input QueryApplicantStatusesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryApplicantStatusesWhereWhereConditions
}

# Order by clause for Query.applicantStatuses.orderBy.
input QueryApplicantStatusesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryApplicantStatusesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.applicantStatuses.orderBy.
enum QueryApplicantStatusesOrderByColumn {
  ID
  NAME
}

# A paginated list of ApplicantStatus items.
type ApplicantStatusPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ApplicantStatus items.
  data: [ApplicantStatus!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `bankCorrespondents`.
input QueryBankCorrespondentsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryBankCorrespondentsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryBankCorrespondentsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryBankCorrespondentsFilterFilterConditions!]
}

# Column names for Query.bankCorrespondents.filter.
enum QueryBankCorrespondentsFilterStatic {
  NAME
  HAS_BANK_CORRESPONDENT_CURRENCIES_FILTER_BY_CURRENCY_ID
  HAS_BANK_CORRESPONDENT_REGIONS_FILTER_BY_REGION_ID
}

# Order by clause for Query.bankCorrespondents.orderBy.
input QueryBankCorrespondentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryBankCorrespondentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.bankCorrespondents.orderBy.
enum QueryBankCorrespondentsOrderByColumn {
  ID
}

# A paginated list of BankCorrespondent items.
type BankCorrespondentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of BankCorrespondent items.
  data: [BankCorrespondent!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `businessActivities`.
input QueryBusinessActivitiesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryBusinessActivitiesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryBusinessActivitiesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryBusinessActivitiesFilterFilterConditions!]
}

# Column names for Query.businessActivities.filter.
enum QueryBusinessActivitiesFilterStatic {
  ID
  NAME
  HAS_COMMISSION_TEMPLATE_FILTER_BY_ID
}

# Order by clause for Query.businessActivities.orderBy.
input QueryBusinessActivitiesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryBusinessActivitiesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.businessActivities.orderBy.
enum QueryBusinessActivitiesOrderByColumn {
  ID
  NAME
}

# A paginated list of BusinessActivity items.
type BusinessActivityPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of BusinessActivity items.
  data: [BusinessActivity!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `commissionPriceLists`.
input QueryCommissionPriceListsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryCommissionPriceListsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionPriceListsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionPriceListsFilterFilterConditions!]
}

# Column names for Query.commissionPriceLists.filter.
enum QueryCommissionPriceListsFilterStatic {
  HAS_PAYMENT_PROVIDER_FILTER_BY_ID
  HAS_COMMISSION_TEMPLATE_FILTER_BY_ID
  HAS_PAYMENT_SYSTEM_FILTER_BY_ID
  ID
  COMPANY_ID
  REGION_ID
}

# Order by clause for Query.commissionPriceLists.orderBy.
input QueryCommissionPriceListsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionPriceListsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionPriceLists.orderBy.
enum QueryCommissionPriceListsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionPriceList items.
type CommissionPriceListPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionPriceList items.
  data: [CommissionPriceList!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `commissionTemplates`.
input QueryCommissionTemplatesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplatesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplatesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplatesFilterFilterConditions!]
}

# Column names for Query.commissionTemplates.filter.
enum QueryCommissionTemplatesFilterStatic {
  ID
  NAME
  IS_ACTIVE
  HAS_COMPANY_FILTER_BY_ID
  HAS_PAYMENT_PROVIDER_FILTER_BY_ID
  HAS_BUSINESS_ACTIVITY_FILTER_BY_ID
}

# Order by clause for Query.commissionTemplates.orderBy.
input QueryCommissionTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplates.orderBy.
enum QueryCommissionTemplatesOrderByColumn {
  ID
  NAME
  IS_ACTIVE
  DESCRIPTION
}

# A paginated list of CommissionTemplate items.
type CommissionTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplate items.
  data: [CommissionTemplate!]!
}

input QueryCommissionTemplateLimitsFilterStatic {
  commission_template_id: ID
  account_id: ID
  payment_system_id: ID
  region_id: ID
  commission_template_limit_action_type_id: ID
  commission_template_limit_type_id: ID
  commission_template_limit_transfer_direction_id: ID
  commission_template_limit_period_id: ID
  currency_id: ID
  amount: Decimal
  period_count: Int
}

# A paginated list of CommissionTemplateLimit items.
type CommissionTemplateLimitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimit items.
  data: [CommissionTemplateLimit!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitActionTypes`.
input QueryCommissionTemplateLimitActionTypesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitActionTypesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitActionTypesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitActionTypesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitActionTypesWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitActionTypes.where.
enum QueryCommissionTemplateLimitActionTypesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitActionTypes`.
input QueryCommissionTemplateLimitActionTypesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitActionTypesWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitActionTypes.orderBy.
input QueryCommissionTemplateLimitActionTypesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitActionTypesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitActionTypes.orderBy.
enum QueryCommissionTemplateLimitActionTypesOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitActionType items.
type CommissionTemplateLimitActionTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitActionType items.
  data: [CommissionTemplateLimitActionType!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitPeriods`.
input QueryCommissionTemplateLimitPeriodsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitPeriodsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitPeriodsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitPeriodsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitPeriodsWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitPeriods.where.
enum QueryCommissionTemplateLimitPeriodsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitPeriods`.
input QueryCommissionTemplateLimitPeriodsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitPeriodsWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitPeriods.orderBy.
input QueryCommissionTemplateLimitPeriodsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitPeriodsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitPeriods.orderBy.
enum QueryCommissionTemplateLimitPeriodsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitPeriod items.
type CommissionTemplateLimitPeriodPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitPeriod items.
  data: [CommissionTemplateLimitPeriod!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitTransferDirections`.
input QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitTransferDirectionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitTransferDirections.where.
enum QueryCommissionTemplateLimitTransferDirectionsWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitTransferDirections`.
input QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitTransferDirectionsWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitTransferDirections.orderBy.
input QueryCommissionTemplateLimitTransferDirectionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitTransferDirectionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitTransferDirections.orderBy.
enum QueryCommissionTemplateLimitTransferDirectionsOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitTransferDirection items.
type CommissionTemplateLimitTransferDirectionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitTransferDirection items.
  data: [CommissionTemplateLimitTransferDirection!]!
}

# Dynamic WHERE conditions for the `where` argument on the query `commissionTemplateLimitTypes`.
input QueryCommissionTemplateLimitTypesWhereWhereConditions {
  # The column that is used for the condition.
  column: QueryCommissionTemplateLimitTypesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCommissionTemplateLimitTypesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCommissionTemplateLimitTypesWhereWhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: QueryCommissionTemplateLimitTypesWhereWhereConditionsRelation
}

# Allowed column names for Query.commissionTemplateLimitTypes.where.
enum QueryCommissionTemplateLimitTypesWhereColumn {
  NAME
}

# Dynamic HAS conditions for WHERE conditions for the `where` argument on the query `commissionTemplateLimitTypes`.
input QueryCommissionTemplateLimitTypesWhereWhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: QueryCommissionTemplateLimitTypesWhereWhereConditions
}

# Order by clause for Query.commissionTemplateLimitTypes.orderBy.
input QueryCommissionTemplateLimitTypesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCommissionTemplateLimitTypesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.commissionTemplateLimitTypes.orderBy.
enum QueryCommissionTemplateLimitTypesOrderByColumn {
  ID
  NAME
}

# A paginated list of CommissionTemplateLimitType items.
type CommissionTemplateLimitTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CommissionTemplateLimitType items.
  data: [CommissionTemplateLimitType!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `companies`.
input QueryCompaniesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryCompaniesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryCompaniesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryCompaniesFilterFilterConditions!]
}

# Column names for Query.companies.filter.
enum QueryCompaniesFilterStatic {
  NAME
  EMAIL
  URL
  REG_NUMBER
  ENTITY_TYPE
  COUNTRY_ID
  HAS_PAYMENT_PROVIDERS_FILTER_BY_ID
  HAS_PAYMENT_SYSTEM_FILTER_BY_ID
  HAS_REGIONS_FILTER_BY_ID
}

# Order by clause for Query.companies.orderBy.
input QueryCompaniesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryCompaniesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.companies.orderBy.
enum QueryCompaniesOrderByColumn {
  ID
  CREATED_AT
  NAME
  EMAIL
  URL
}

# A paginated list of Company items.
type CompanyPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Company items.
  data: [Company!]!
}

# A paginated list of Country items.
type CountryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Country items.
  data: [Country!]!
}

# A paginated list of Currencies items.
type CurrenciesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Currencies items.
  data: [Currencies!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `departments`.
input QueryDepartmentsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryDepartmentsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentsFilterFilterConditions!]
}

# Column names for Query.departments.filter.
enum QueryDepartmentsFilterStatic {
  HAS_COMPANY_FILTER_BY_ID
  NAME
}

# Order by clause for Query.departments.orderBy.
input QueryDepartmentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryDepartmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.departments.orderBy.
enum QueryDepartmentsOrderByColumn {
  ID
  NAME
}

# A paginated list of Department items.
type DepartmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Department items.
  data: [Department!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `departmentPositions`.
input QueryDepartmentPositionsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryDepartmentPositionsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryDepartmentPositionsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryDepartmentPositionsFilterFilterConditions!]
}

# Column names for Query.departmentPositions.filter.
enum QueryDepartmentPositionsFilterStatic {
  HAS_DEPARTMENT_FILTER_BY_ID
  NAME
  IS_ACTIVE
}

# Order by clause for Query.departmentPositions.orderBy.
input QueryDepartmentPositionsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryDepartmentPositionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.departmentPositions.orderBy.
enum QueryDepartmentPositionsOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of DepartmentPosition items.
type DepartmentPositionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of DepartmentPosition items.
  data: [DepartmentPosition!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `emailNotifications`.
input QueryEmailNotificationsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryEmailNotificationsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryEmailNotificationsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryEmailNotificationsFilterFilterConditions!]
}

# Column names for Query.emailNotifications.filter.
enum QueryEmailNotificationsFilterStatic {
  COMPANY_ID
  TYPE
  RECIPIENT_TYPE
  HAS_APPLICANT_INDIVIDUAL_MIXED_ID_OR_FULLNAME
  HAS_APPLICANT_COMPANY_MIXED_ID_OR_NAME
  HAS_GROUP_ROLE_MIXED_ID_OR_NAME
  HAS_MEMBER_MIXED_ID_OR_FULLNAME
  HAS_GROUP_TYPE_MIXED_ID_OR_NAME
  HAS_TEMPLATES_FILTER_BY_SUBJECT
}

# Order by clause for Query.emailNotifications.orderBy.
input QueryEmailNotificationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryEmailNotificationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.emailNotifications.orderBy.
enum QueryEmailNotificationsOrderByColumn {
  ID
}

# A paginated list of EmailNotification items.
type EmailNotificationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of EmailNotification items.
  data: [EmailNotification!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `files`.
input QueryFilesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryFilesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryFilesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryFilesFilterFilterConditions!]
}

# Column names for Query.files.filter.
enum QueryFilesFilterStatic {
  AUTHOR_ID
  ENTITY_TYPE
}

# Order by clause for Query.files.orderBy.
input QueryFilesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryFilesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.files.orderBy.
enum QueryFilesOrderByColumn {
  ID
  AUTHOR_ID
}

# A paginated list of Files items.
type FilesPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Files items.
  data: [Files!]!
}

enum GroupTypeMode {
  CLIENTS
  ALL
}

# A paginated list of GroupType items.
type GroupTypePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of GroupType items.
  data: [GroupType!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `groups`.
input QueryGroupsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryGroupsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupsFilterFilterConditions!]
}

# Column names for Query.groups.filter.
enum QueryGroupsFilterStatic {
  ID
  COMPANY_ID
  ROLE_ID
  NAME
  GROUP_TYPE_ID
  IS_ACTIVE
}

# Order by clause for Query.groups.orderBy.
input QueryGroupsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGroupsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.groups.orderBy.
enum QueryGroupsOrderByColumn {
  ID
  IS_ACTIVE
  NAME
}

# A paginated list of GroupRole items.
type GroupRolePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of GroupRole items.
  data: [GroupRole!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `groupList`.
input QueryGroupListFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryGroupListFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryGroupListFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryGroupListFilterFilterConditions!]
}

# Column names for Query.groupList.filter.
enum QueryGroupListFilterStatic {
  ID
  COMPANY_ID
  NAME
  ROLE_ID
  GROUP_TYPE_ID
  IS_ACTIVE
  MODULE_ID
  COMMISSION_TEMPLATE_ID
  PAYMENT_PROVIDER_ID
}

# Order by clause for Query.groupList.orderBy.
input QueryGroupListOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryGroupListOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.groupList.orderBy.
enum QueryGroupListOrderByColumn {
  ID
  IS_ACTIVE
  NAME
}

# A paginated list of GroupRoleView items.
type GroupRoleViewPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of GroupRoleView items.
  data: [GroupRoleView!]!
}

type GroupRoleView {
  id: ID!

  # Название группы
  name: String

  # ID типа группы
  group_type_id: ID

  # ID роли
  role_id: ID

  # ID модуля
  module_id: ID

  # Описание группы
  description: String

  # Активная и не активная группа
  is_active: Boolean

  # Получить тип группы
  group_type: GroupType

  # Получить связанную роль
  role: Role

  # ID шаблона коммиссии
  commission_template_id: ID

  # Имя шаблона коммиссии
  commission_template_name: String

  # ID провайдера
  payment_provider_id: ID

  # Имя провайдера
  payment_provider_name: String

  # Получить компанию
  company: Company

  # Получить связанный модуль
  module: Module
}

# Dynamic WHERE conditions for the `filter` argument on the query `memberAccessLimitations`.
input QueryMemberAccessLimitationsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryMemberAccessLimitationsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMemberAccessLimitationsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMemberAccessLimitationsFilterFilterConditions!]
}

# Column names for Query.memberAccessLimitations.filter.
enum QueryMemberAccessLimitationsFilterStatic {
  DOESNT_HAVE_GROUP_ROLES
  HAS_GROUP_ROLES_FILTER_BY_ID
  MODULE_ID
  PROJECT_ID
  PAYMENT_PROVIDER_ID
  GROUP_TYPE_ID
}

# Order by clause for Query.memberAccessLimitations.orderBy.
input QueryMemberAccessLimitationsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryMemberAccessLimitationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.memberAccessLimitations.orderBy.
enum QueryMemberAccessLimitationsOrderByColumn {
  ID
}

# A paginated list of MemberAccessLimitation items.
type MemberAccessLimitationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of MemberAccessLimitation items.
  data: [MemberAccessLimitation!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `members`.
input QueryMembersFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryMembersFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryMembersFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryMembersFilterFilterConditions!]
}

# Column names for Query.members.filter.
enum QueryMembersFilterStatic {
  HAS_GROUP_ROLE_FILTER_BY_ID
  HAS_ROLE_FILTER_BY_ID
  ID
  FULLNAME
  COMPANY_ID
  EMAIL
  DEPARTMENT_POSITION_ID
  DEPARTMENT_ID
  LAST_LOGIN_AT
  IS_SHOW_OWNER_APPLICANTS
  MEMBER_STATUS_ID
}

# Order by clause for Query.members.orderBy.
input QueryMembersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryMembersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.members.orderBy.
enum QueryMembersOrderByColumn {
  ID
  EMAIL
  LAST_LOGIN_AT
  IS_ACTIVE
}

# A paginated list of Members items.
type MembersPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Members items.
  data: [Members!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `paymentBanks`.
input QueryPaymentBanksFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentBanksFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentBanksFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentBanksFilterFilterConditions!]
}

# Column names for Query.paymentBanks.filter.
enum QueryPaymentBanksFilterStatic {
  ID
  COUNTRY_ID
  PAYMENT_SYSTEM_ID
  PAYMENT_PROVIDER_ID
  NAME
  ADDRESS
  BANK_CODE
  PAYMENT_SYSTEM_CODE
}

input QueryPaymentBankCondition {
  country_id: ID
  name: String
  address: String
  bank_code: String
  payment_system_code: String
  payment_provider_id: ID!
  payment_system_id: ID!
}

# Order by clause for Query.paymentBanks.orderBy.
input QueryPaymentBanksOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentBanksOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentBanks.orderBy.
enum QueryPaymentBanksOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of PaymentBank items.
type PaymentBankPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentBank items.
  data: [PaymentBank!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `paymentProviders`.
input QueryPaymentProvidersFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentProvidersFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentProvidersFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentProvidersFilterFilterConditions!]
}

# Column names for Query.paymentProviders.filter.
enum QueryPaymentProvidersFilterStatic {
  NAME
  HAS_PAYMENT_SYSTEMS_FILTER_BY_ID
  HAS_ACCOUNT_FILTER_BY_ID
  HAS_COMMISSION_TEMPLATE_FILTER_BY_ID
  COMPANY_ID
  ID
}

# Order by clause for Query.paymentProviders.orderBy.
input QueryPaymentProvidersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentProvidersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentProviders.orderBy.
enum QueryPaymentProvidersOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of PaymentProvider items.
type PaymentProviderPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentProvider items.
  data: [PaymentProvider!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `paymentProviderIbans`.
input QueryPaymentProviderIbansFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentProviderIbansFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentProviderIbansFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentProviderIbansFilterFilterConditions!]
}

# Column names for Query.paymentProviderIbans.filter.
enum QueryPaymentProviderIbansFilterStatic {
  NAME
  COMPANY_ID
  CURRENCY_ID
}

# Order by clause for Query.paymentProviderIbans.orderBy.
input QueryPaymentProviderIbansOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentProviderIbansOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentProviderIbans.orderBy.
enum QueryPaymentProviderIbansOrderByColumn {
  ID
}

# A paginated list of PaymentProviderIban items.
type PaymentProviderIbanPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentProviderIban items.
  data: [PaymentProviderIban!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `paymentSystems`.
input QueryPaymentSystemsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentSystemsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentSystemsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentSystemsFilterFilterConditions!]
}

# Column names for Query.paymentSystems.filter.
enum QueryPaymentSystemsFilterStatic {
  ID
  NAME
  HAS_PROVIDERS_FILTER_BY_NAME
  HAS_PROVIDERS_FILTER_BY_ID
  HAS_COMPANIES_FILTER_BY_ID
  HAS_REGIONS_FILTER_BY_ID
}

# Order by clause for Query.paymentSystems.orderBy.
input QueryPaymentSystemsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentSystemsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.paymentSystems.orderBy.
enum QueryPaymentSystemsOrderByColumn {
  ID
  NAME
  IS_ACTIVE
}

# A paginated list of PaymentSystem items.
type PaymentSystemPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentSystem items.
  data: [PaymentSystem!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `payments`.
input QueryPaymentsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryPaymentsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryPaymentsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryPaymentsFilterFilterConditions!]
}

# Column names for Query.payments.filter.
enum QueryPaymentsFilterStatic {
  ID
  COMPANY_ID
  PAYMENT_PROVIDER_ID
  OPERATION_TYPE_ID
  URGENCY_ID
  STATUS_ID
  SENDER_NAME
  HAS_ACCOUNT_FILTER_BY_ACCOUNT_NUMBER
}

# Order by clause for Query.payments.orderBy.
input QueryPaymentsOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryPaymentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.payments.orderBy.
enum QueryPaymentsOrderByColumn {
  ID
  CREATED_AT
  AMOUNT
  FEE
  PAYMENT_NUMBER
}

# A paginated list of Payments items.
type PaymentsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Payments items.
  data: [Payments!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `projects`.
input QueryProjectsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryProjectsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryProjectsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryProjectsFilterFilterConditions!]
}

# Column names for Query.projects.filter.
enum QueryProjectsFilterStatic {
  ID
  COMPANY_ID
  MODULE_ID
}

# A paginated list of Project items.
type ProjectPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Project items.
  data: [Project!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `regions`.
input QueryRegionsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryRegionsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRegionsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRegionsFilterFilterConditions!]
}

# Column names for Query.regions.filter.
enum QueryRegionsFilterStatic {
  COMPANY_ID
  HAS_COUNTRIES_FILTER_BY_ID
  HAS_COUNTRIES_FILTER_BY_NAME
  HAS_PAYMENT_SYSTEM_MIXED_ID_OR_NAME
}

# A paginated list of Region items.
type RegionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Region items.
  data: [Region!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `roles`.
input QueryRolesFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryRolesFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryRolesFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryRolesFilterFilterConditions!]
}

# Column names for Query.roles.filter.
enum QueryRolesFilterStatic {
  NAME
  COMPANY_ID
  HAS_GROUP_TYPE_MIXED_ID_OR_NAME
  HAS_GROUPS_MIXED_ID_OR_NAME
}

# Order by clause for Query.roles.orderBy.
input QueryRolesOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryRolesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.roles.orderBy.
enum QueryRolesOrderByColumn {
  ID
  NAME
  DESCRIPTION
}

# A paginated list of Role items.
type RolePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Role items.
  data: [Role!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `tickets`.
input QueryTicketsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryTicketsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTicketsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTicketsFilterFilterConditions!]
}

# Column names for Query.tickets.filter.
enum QueryTicketsFilterStatic {
  ID
  MEMBER_ID
  CLIENT_ID
  HAS_COMPANY_FILTER_BY_ID
}

# Order by clause for Query.tickets.orderBy.
input QueryTicketsOrderByRelationOrderByClause {
  # The column that is used for ordering.
  column: QueryTicketsOrderByColumn

  # The direction that is used for ordering.
  order: SortOrder!

  # Aggregate specification.
  company: QueryTicketsOrderByCompany

  # Aggregate specification.
  department: QueryTicketsOrderByDepartment
}

# Allowed column names for Query.tickets.orderBy.
enum QueryTicketsOrderByColumn {
  ID
}

# Aggregate specification for Query.tickets.orderBy.company.
input QueryTicketsOrderByCompany {
  # Always COUNT.
  aggregate: OrderByRelationAggregateFunction!
}

# Aggregate functions when ordering by a relation without specifying a column.
enum OrderByRelationAggregateFunction {
  # Amount of items.
  COUNT
}

# Aggregate specification for Query.tickets.orderBy.department.
input QueryTicketsOrderByDepartment {
  # Always COUNT.
  aggregate: OrderByRelationAggregateFunction!
}

# A paginated list of Ticket items.
type TicketPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Ticket items.
  data: [Ticket!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `transferIncomings`.
input QueryTransferIncomingsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryTransferIncomingsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTransferIncomingsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTransferIncomingsFilterFilterConditions!]
}

# Column names for Query.transferIncomings.filter.
enum QueryTransferIncomingsFilterStatic {
  ID
  URGENCY_ID
  OPERATION_TYPE_ID
  SENDER_NAME
  STATUS_ID
  HAS_ACCOUNT_FILTER_BY_ACCOUNT_NUMBER
  HAS_FEE_FILTER_BY_FEE
  HAS_FEE_FILTER_BY_FEE_AMOUNT
}

# A paginated list of TransferIncoming items.
type TransferIncomingPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TransferIncoming items.
  data: [TransferIncoming!]!
}

# A paginated list of TransferIncomingHistory items.
type TransferIncomingHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TransferIncomingHistory items.
  data: [TransferIncomingHistory!]!
}

# История входящих переводов
type TransferIncomingHistory {
  id: ID!

  # Статус
  status: PaymentStatus

  # Действие
  action: String

  # Комментарий
  comment: String

  # Дата
  created_at: DateTimeUtc
}

# Dynamic WHERE conditions for the `filter` argument on the query `transferOutgoings`.
input QueryTransferOutgoingsFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryTransferOutgoingsFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryTransferOutgoingsFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryTransferOutgoingsFilterFilterConditions!]
}

# Column names for Query.transferOutgoings.filter.
enum QueryTransferOutgoingsFilterStatic {
  ID
  URGENCY_ID
  OPERATION_TYPE_ID
  STATUS_ID
  RECIPIENT_NAME
  USER_TYPE
  HAS_ACCOUNT_FILTER_BY_ACCOUNT_NUMBER
  HAS_SENDER_MIXED_NAME_OR_FULLNAME
  HAS_FEE_FILTER_BY_FEE
  HAS_FEE_FILTER_BY_FEE_AMOUNT
}

# A paginated list of TransferOutgoing items.
type TransferOutgoingPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TransferOutgoing items.
  data: [TransferOutgoing!]!
}

# A paginated list of TransferOutgoingHistory items.
type TransferOutgoingHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TransferOutgoingHistory items.
  data: [TransferOutgoingHistory!]!
}

# История исходящих переводов
type TransferOutgoingHistory {
  id: ID!

  # Статус
  status: PaymentStatus

  # Действие
  action: String

  # Комментарий
  comment: String

  # Дата
  created_at: DateTimeUtc
}

# A paginated list of TwoFactorAuthSettings items.
type TwoFactorAuthSettingsPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TwoFactorAuthSettings items.
  data: [TwoFactorAuthSettings!]!
}

# Dynamic WHERE conditions for the `filter` argument on the query `users`.
input QueryUsersFilterFilterConditions {
  # The column that is used for the condition.
  column: QueryUsersFilterStatic

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [QueryUsersFilterFilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [QueryUsersFilterFilterConditions!]
}

# Column names for Query.users.filter.
enum QueryUsersFilterStatic {
  ID
  FULLNAME
  COMPANY_ID
  EMAIL
  GROUP_ID
  GROUP_TYPE_ID
  ROLE_ID
}

# Order by clause for Query.users.orderBy.
input QueryUsersOrderByOrderByClause {
  # The column that is used for ordering.
  column: QueryUsersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for Query.users.orderBy.
enum QueryUsersOrderByColumn {
  ID
  EMAIL
  FULLNAME
}

# A paginated list of Users items.
type UsersPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Users items.
  data: [Users!]!
}

type Mutation {
  # Создать лимит
  createAccountLimit(
    # ID account
    account_id: ID!

    # ID типа лимита
    commission_template_limit_type_id: ID!

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID!

    # Сумма лимита
    amount: Decimal!

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID!

    # ID события лимита
    commission_template_limit_action_type_id: ID!

    # ID количество срабатываний лимита
    period_count: ID
  ): AccountLimit

  # Обновить лимит
  updateAccountLimit(
    # ID шаблона
    id: ID!

    # ID типа лимита
    commission_template_limit_type_id: ID

    # ID направления платежа
    commission_template_limit_transfer_direction_id: ID

    # Сумма лимита
    amount: Decimal

    # ID валюты лимита
    currency_id: ID

    # ID периода лимита
    commission_template_limit_period_id: ID

    # ID события лимита
    commission_template_limit_action_type_id: ID

    # количество срабатываний лимита
    period_count: ID
  ): AccountLimit

  # Удалить лимит
  deleteAccountLimit(id: ID!): AccountLimit

  # Создать аккаунт
  createAccount(input: InputAccount!): [Account!]!

  # Редактирование аккаунта
  updateAccount(
    id: ID!

    # Имя аккаунта
    account_name: String!

    # Состояние аккаунта
    account_state_id: ID!

    # Основной или нет
    is_primary: Boolean!
  ): Account

  # Удалить аккаунт
  deleteAccount(id: ID!): Account

  # Генерация iban individual
  generateIban(id: ID!): AccountGenerateIbanResponse!

  # Изменение Active Session
  updateActiveSession(
    id: String!

    # Название
    trusted: Boolean!
  ): ActiveSessionMutatorResponse!

  # Создать частного пользователя
  createApplicantIndividual(
    # Имя
    first_name: String!

    # Фамилия
    last_name: String!

    # email
    email: EMAIL!

    # Телефон
    phone: String!

    # ID компании
    company_id: ID!

    # ID photo
    photo_id: ID

    # ID модулей
    module_ids: [ID]

    # ID Проекта
    project_id: ID

    # ID группы
    group_id: ID
  ): ApplicantIndividual

  # Редактирование частного пользователя
  updateApplicantIndividual(
    id: ID!

    # Имя
    first_name: String

    # Фамилия
    last_name: String

    # Отчество
    middle_name: String

    # email
    email: EMAIL

    # Адрес сайта
    url: String

    # Телефон
    phone: String

    # Верецифиорован телефон true/false
    is_verification_phone: Boolean

    # ID Страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID страны гражданства
    citizenship_country_id: ID

    # Штат / область
    state: String

    # Город
    city: String

    # Адрес
    address: String

    # Индекс
    zip: String

    # Национальность
    nationality: String

    # ID страны рождения
    birth_country_id: ID

    # Штат/область рождения
    birth_state: String

    # Город рождения
    birth_city: String

    # Дата рождения
    birth_at: Date

    # Пол
    sex: Sex

    # Дополнительные поля Profile data
    profile_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля для Personal info
    personal_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля
    address_additional_fields: [AdditionalFieldInput]

    # ID состояния
    applicant_state_id: ID

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID менеджера
    account_manager_member_id: ID

    # ID компании
    company_id: ID

    # Массив ID меток
    labels: [ID]

    # ID группы
    group_id: ID

    # ID модулей
    module_ids: [ID]

    # ID Проекта
    project_id: ID

    # Two factor auth
    two_factor_auth_setting_id: ID

    # Пароль
    password: String

    # Подтверждение пароля
    password_confirmation: String

    # IP адрес
    ip_address: String

    # ID photo
    photo_id: ID

    # KYC Level
    kyc_level_id: ID

    # время последний просмотренный
    last_screened_at: DateTimeUtc
  ): ApplicantIndividual

  # Изменить статус аппликанта
  updateApplicantIndividualVerificationStatus(
    id: ID!

    # ID статуса
    applicant_status_id: ID!
  ): ApplicantIndividual

  # Установить пароль
  setApplicantIndividualPassword(
    id: ID!

    # пароль
    password: String!

    # подтверждение пароля
    password_confirmation: String!
  ): ApplicantIndividual

  # Установить PIN пользователю
  setApplicantSecurityPin(id: ID!): ApplicantIndividual

  # Удалить пользователя
  deleteApplicantIndividual(id: ID!): ApplicantIndividual

  # Отправить ссылку для подтверждения email
  sendEmailVerification(applicant_id: ID!): ApplicantIndividual

  # Отправить подтверждение телефона
  sendPhoneVerification(applicant_id: ID!): ApplicantIndividual

  # Сбросить пароль участнику
  sendEmailResetPassword(applicant_id: ID!, email: String): ApplicantIndividual

  # Отправить ссылку на регистрацию
  sendEmailRegistation(applicant_id: ID!, email: String): ApplicantIndividual

  # Создать applicant company
  createApplicantBankingAccess(
    # Applicant individual
    applicant_individual_id: ID!

    # Applicant company
    applicant_company_id: ID!

    # ID роли
    role_id: ID!

    # Contact administrator
    contact_administrator: Boolean!

    # Ежедневный лимит
    daily_limit: Decimal!

    # Ежемесячный лимит
    monthly_limit: Decimal!

    # Лимит операций
    operation_limit: Decimal!

    # Использованный лимит
    used_limit: Decimal
  ): ApplicantBankingAccess

  # Редактирование applicant banking access
  updateApplicantBankingAccess(
    id: ID!

    # Applicant individual
    applicant_individual_id: ID

    # Applicant company
    applicant_company_id: ID

    # ID роли
    role_id: ID

    # Contact administrator
    contact_administrator: Boolean

    # Ежедневный лимит
    daily_limit: Decimal

    # Ежемесячный лимит
    monthly_limit: Decimal

    # Лимит операций
    operation_limit: Decimal
  ): ApplicantBankingAccess

  # Удалить пользователя
  deleteApplicantBankingMember(id: ID!): ApplicantBankingAccess

  # Предоставить доступ
  grantApplicantBankingAccess(id: ID!): ApplicantBankingAccess

  # Отозвать доступ
  deleteApplicantBankingAccess(id: ID!): ApplicantBankingAccess

  # Создать applicant company
  createApplicantCompany(
    # Название
    name: String!

    # email
    email: EMAIL!

    # Телефон
    phone: String

    # ID компании
    company_id: ID!

    # ID модулей
    module_ids: [ID]

    # ID группы
    group_id: ID

    # ID проекта
    project_id: ID!

    # ID owner
    owner_id: ID

    # ID relation владельца
    owner_relation_id: ID

    # ID position владельца
    owner_position_id: ID

    # ID photo
    photo_id: ID
  ): ApplicantCompany

  # Редактирование applicant company
  updateApplicantCompany(
    id: ID!

    # Название
    name: String

    # email
    email: EMAIL

    # Адрес сайта
    url: String

    # Телефон
    phone: String

    # Верецифиорован телефон true/false
    is_verification_phone: Boolean

    # страна
    country_id: ID

    # ID языка
    language_id: ID

    # Штат / область
    state: String

    # Город
    city: String

    # Адрес
    address: String

    # Адрес2
    address2: String

    # Адрес офиса
    office_address: String

    # Индекс
    zip: String

    # Дата регистрации
    reg_at: Date

    # Дата окончания регистрации
    expires_at: DateTimeUtc

    # Налоговый номер
    tax: String

    # Регистрационный номер
    reg_number: String

    # Номер лицензии
    license_number: String

    # Тип компании
    company_type: String

    # Дополнительные поля Company Info
    company_info_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля блока контакты
    contacts_additional_fields: [AdditionalFieldInput]

    # Дополнительные поля Profile data
    profile_additional_fields: [AdditionalFieldInput]

    # ID типа бизнеса
    applicant_company_business_type_id: ID

    # ID состояния
    applicant_state_id: ID

    # ID причины
    applicant_state_reason_id: ID

    # ID уровня рисков
    applicant_risk_level_id: ID

    # ID KYC level
    applicant_kyc_level_id: ID

    # ID менеджера
    account_manager_member_id: ID

    # ID компании
    company_id: ID

    # ID owner
    owner_id: ID

    # ID relation владельца
    owner_relation_id: ID

    # ID position владельца
    owner_position_id: ID

    # Массив ID меток
    labels: [ID]

    # ID группы
    group_id: ID

    # ID модулей
    module_ids: [ID]

    # ID проекта
    project_id: ID

    # ID photo
    photo_id: ID

    # Дата включуения
    incorporate_date: DateTimeUtc

    # Дополнительные поля Basic info
    basic_info_additional_field: [AdditionalFieldInput]

    # Контактный email
    contact_email: EMAIL

    # Контактный телефон
    contact_phone: String
  ): ApplicantCompany

  # Удалить applicant company
  deleteApplicantCompany(id: ID!): ApplicantCompany

  # Изменить статус applicant company
  updateApplicantCompanyVerificationStatus(
    id: ID!

    # ID статуса
    applicant_status_id: ID!
  ): ApplicantCompany

  # Добавить связь Individual с Company
  createApplicantIndividualCompany(
    applicant_id: ID!
    applicant_company_id: ID!
    applicant_individual_company_relation_id: ID!
    applicant_individual_company_position_id: ID!
    percentage_owned: Float
  ): ApplicantIndividualCompany

  # Редактировать связь Individual с Company
  updateApplicantIndividualCompany(
    applicant_id: ID!
    applicant_company_id: ID!
    applicant_individual_company_relation_id: ID
    applicant_individual_company_position_id: ID
    percentage_owned: Float
  ): ApplicantIndividualCompany

  # Удалить связь Individual с Company
  deleteApplicantIndividualCompany(
    applicant_id: ID!
    applicant_company_id: ID!
  ): ApplicantIndividualCompany

  # Отправить ссылку для подтверждения email
  sendEmailVerificationApplicantCompany(
    applicant_company_id: ID!
  ): ApplicantCompany

  # Отправить подтверждение телефона
  sendPhoneVerificationApplicantCompany(
    applicant_company_id: ID!
  ): ApplicantCompany

  # Создать бизнес тип
  createApplicantCompanyBusinessType(
    # Название
    name: String!
  ): ApplicantCompanyBusinessType

  # Редактирование отнощения
  updateApplicantCompanyBusinessType(
    # ID бизнес типа
    id: ID!

    # Название
    name: String!
  ): ApplicantCompanyBusinessType

  # Создать метку
  createApplicantCompanyLabel(
    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String!
  ): ApplicantCompanyLabel

  # Редактирование метки
  updateApplicantCompanyLabel(
    # ID метки
    id: ID!

    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String
  ): ApplicantCompanyLabel

  # Удалит метку
  deleteApplicantCompanyLabel(
    id: ID!
    deleteAnyway: Boolean
  ): ApplicantCompanyLabel

  # Создать метку компании
  attachApplicantCompanyLabel(
    # Аппликант
    applicant_company_id: ID!

    # Метка
    applicant_company_label_id: [ID]
  ): ApplicantCompany

  # Удалить метку
  detachApplicantCompanyLabel(
    applicant_company_id: ID!
    applicant_company_label_id: [ID]
  ): ApplicantCompany

  # Создать модуль компании
  createApplicantCompanyModule(
    # Компания
    applicant_company_id: ID!

    # Модуль
    module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantCompany

  # Активировать модуль applicant company
  updateApplicantCompanyModule(
    # Аппликант
    applicant_company_id: ID!

    # Модуль
    module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantCompany

  # Удалить модуль
  deleteApplicantCompanyModule(
    applicant_company_id: ID!
    module_id: [ID]
  ): ApplicantCompany

  # Создать заметку
  createApplicantCompanyNote(
    # Текст заметки
    note: String!

    # ID пользователя
    applicant_company_id: ID!

    # ID автора заметки
    member_id: ID!
  ): ApplicantCompanyNotes

  # Удалит заметку
  deleteApplicantCompanyNote(id: ID!): ApplicantCompanyNotes

  # Добавить запись
  createApplicantCompanyRiskLevelHistory(
    # Комментарий
    comment: String!

    # Аппликант
    applicant_company_id: ID!

    # Уровень риска
    risk_level_id: ID!
  ): ApplicantCompanyRiskLevelHistory

  # Удалить запись
  deleteApplicantCompanyRiskLevelHistory(
    id: ID!
  ): ApplicantCompanyRiskLevelHistory

  # Добавить документ
  createApplicantDocument(
    company_id: ID!
    applicant_id: ID!
    applicant_type: ApplicantType!
    document_type_id: ID!
    document_state_id: ID
    file_id: ID!
    country_id: ID
    added_from: String
    info: String
  ): ApplicantDocument

  # Обновить документ
  updateApplicantDocument(
    id: ID!
    document_state_id: ID
    info: String
  ): ApplicantDocument

  # Удалить документ
  deleteApplicantDocument(id: ID!): ApplicantDocument

  # Прикрепить тег к документу
  attachApplicantDocumentTag(
    applicant_document_id: ID!
    applicant_document_tag_id: [ID]!
  ): ApplicantDocument

  # Открепить тег от документа
  detachApplicantDocumentTag(
    applicant_document_id: ID!
    applicant_document_tag_id: [ID]!
  ): ApplicantDocument

  # Добавить заметку к документу
  createApplicantDocumentInternalNote(
    applicant_document_id: ID!
    note: String!
  ): ApplicantDocumentInternalNote

  # Удалить заметку
  deleteApplicantDocumentInternalNote(id: ID!): ApplicantDocumentInternalNote

  # Создать отклонение документа
  createApplicantDocumentRejectDetail(
    applicant_document_id: ID!
    applicant_document_tag_id: [ID!]!
  ): ApplicantDocumentRejectDetail

  # Удалить тег из отклонения документа
  deleteTagApplicantDocumentRejectDetail(
    id: ID!
    applicant_document_tag_id: [ID]
  ): ApplicantDocumentRejectDetail

  # Удалить отклонение документа
  deleteApplicantDocumentRejectDetail(id: ID!): ApplicantDocumentRejectDetail

  # Добавить тег
  createApplicantDocumentTag(
    category_id: ID!
    name: String!
    description: String
  ): ApplicantDocumentTag

  # Обновить тег
  updateApplicantDocumentTag(
    id: ID!
    category_id: ID!
    name: String!
    description: String
  ): ApplicantDocumentTag

  # Удалить тег
  deleteApplicantDocumentTag(id: ID!): ApplicantDocumentTag

  # Добавить категорию
  createApplicantDocumentTagCategory(
    name: String!
  ): ApplicantDocumentTagCategory

  # Обновить категорию
  updateApplicantDocumentTagCategory(
    id: ID!
    name: String!
  ): ApplicantDocumentTagCategory

  # Удалить категорию
  deleteApplicantDocumentTagCategory(id: ID!): ApplicantDocumentTagCategory

  # Создать должность
  createApplicantIndividualCompanyPosition(
    # Название
    name: String!

    # Компания
    company_id: ID!
  ): ApplicantIndividualCompanyPosition

  # Редактирование должности
  updateApplicantIndividualCompanyPosition(
    # ID должности
    id: ID!

    # Название
    name: String!

    # Компания
    company_id: ID
  ): ApplicantIndividualCompanyPosition

  # Удаление должности
  deleteApplicantIndividualCompanyPosition(
    # ID должности
    id: ID!
  ): ApplicantIndividualCompanyPosition

  # Создать отношение
  createApplicantIndividualCompanyRelation(
    # Название
    name: String!

    # Компания
    company_id: ID!
  ): ApplicantIndividualCompanyRelation

  # Редактирование отношения
  updateApplicantIndividualCompanyRelation(
    # ID отношения
    id: ID!

    # Название
    name: String!

    # Компания
    company_id: ID
  ): ApplicantIndividualCompanyRelation

  # Удалить отношения
  deleteApplicantIndividualCompanyRelation(
    # ID отношения
    id: ID!
  ): ApplicantIndividualCompanyRelation

  # Создать модуль аппликанта
  createApplicantIndividualModule(
    # Аппликант
    applicant_individual_id: ID!

    # Модуль
    module_id: [ID]
  ): ApplicantIndividual

  # Активировать или деактивировать модуль аппликанту
  updateApplicantIndividualModule(
    # Аппликант
    applicant_individual_id: ID!

    # Модуль
    module_id: [ID]

    # Активный или неактивный
    is_active: Boolean
  ): ApplicantIndividual

  # Удалить модуль
  deleteApplicantIndividualModule(
    applicant_individual_id: ID!
    module_id: [ID]
  ): ApplicantIndividual

  # Добавить запись
  createApplicantRiskLevelHistory(
    # Комментарий
    comment: String!

    # Аппликант
    applicant_id: ID!

    # Уровень риска
    risk_level_id: ID!
  ): ApplicantRiskLevelHistory

  # Удалить запись
  deleteApplicantRiskLevelHistory(id: ID!): ApplicantRiskLevelHistory

  # Создать метку
  createApplicantIndividualLabel(
    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String!
  ): ApplicantIndividualLabel

  # Редактирование метки
  updateApplicantIndividualLabel(
    # ID метки
    id: ID!

    # Название метки
    name: String!

    # HEX код метки
    hex_color_code: String
  ): ApplicantIndividualLabel

  # Удалить метку
  deleteApplicantIndividualLabel(
    id: ID!
    deleteAnyway: Boolean
  ): ApplicantIndividualLabel

  # Создать метку аппликанту
  attachApplicantIndividualLabel(
    # Аппликант
    applicant_individual_id: ID!

    # Метка
    applicant_individual_label_id: [ID]
  ): ApplicantIndividual

  # Удалить метку
  detachApplicantIndividualLabel(
    applicant_individual_id: ID!
    applicant_individual_label_id: [ID]
  ): ApplicantIndividual

  # Создать модуль
  createApplicantModule(
    # Название модуля
    name: String!
  ): ApplicantModules

  # Создать заметку
  createApplicantIndividualNote(
    # Текст заметки
    note: String!

    # ID пользователя
    applicant_individual_id: ID!

    # ID автора заметки
    member_id: ID!
  ): ApplicantIndividualNotes

  # Удалит заметку
  deleteApplicantIndividualNote(id: ID!): ApplicantIndividualNotes

  # Создать причину
  createApplicantStateReason(
    # Название
    name: String!
  ): ApplicantStateReason

  # Редактирование причины
  updateApplicantStateReason(
    # ID метки
    id: ID!

    # Название
    name: String!
  ): ApplicantStateReason

  # Удалит метку
  deleteApplicantStateReason(id: ID!): ApplicantStateReason

  # Создать банк корреспондент
  createBankCorrespondent(
    # Название
    name: String!

    # Адрес
    address: String!

    # SWIFT
    bank_code: String!

    # Счет банка корреспондента
    bank_account: String!

    # ID платежной системы
    payment_system_id: ID!

    # ID валют
    currency_id: [ID]!

    # ID регионов
    region_id: [ID]!

    # Активность
    is_active: Boolean!
  ): BankCorrespondent

  # Обновить банк корреспондент
  updateBankCorrespondent(
    # ID проекта
    id: ID!

    # Название
    name: String!

    # Адрес
    address: String!

    # SWIFT
    bank_code: String!

    # Счет банка корреспондента
    bank_account: String!

    # ID платежной системы
    payment_system_id: ID!

    # ID валют
    currency_id: [ID]!

    # ID регионов
    region_id: [ID]!

    # Активность
    is_active: Boolean!
  ): BankCorrespondent

  # Удалить банк корреспондент
  deleteBankCorrespondent(id: ID!): BankCorrespondent

  # Создание Business Activity
  createBusinessActivity(
    # Название
    name: String!
  ): BusinessActivity

  # Изменение Business Activity
  updateBusinessActivity(
    id: ID!

    # Название
    name: String!
  ): BusinessActivity

  # Создать прай лист
  createCommissionPriceList(
    # Название шаблона
    name: String!

    # ID платежного провайдера
    provider_id: ID!

    # ID платежной системы
    payment_system_id: ID!

    # ID платежного шаблона
    commission_template_id: ID!

    # ID Региона
    region_id: ID!

    # ID Компании
    company_id: ID!
  ): CommissionPriceList

  # Редактирование частного пользователя
  updateCommissionPriceList(
    id: ID!

    # Название шаблона
    name: String

    # ID платежного провайдера
    provider_id: ID

    # ID платежной системы
    payment_system_id: ID

    # ID платежного шаблона
    commission_template_id: ID

    # ID Региона
    region_id: ID

    # ID Компании
    company_id: ID
  ): CommissionPriceList

  # Удалить прайс лист
  deleteCommissionPriceList(id: ID!): CommissionPriceList

  # Создание шаблона комиссий
  createCommissionTemplate(input: InputCommissionTemplate!): CommissionTemplate

  # Обновление полей шаблона комиссий
  updateCommissionTemplate(
    # ID шаблона
    id: ID!
    input: InputCommissionTemplate!
  ): CommissionTemplate

  # Удалить шаблон
  deleteCommissionTemplate(id: ID!): CommissionTemplate

  # Создать лимит
  createCommissionTemplateLimit(
    input: InputCommissionTemplateLimit!
  ): CommissionTemplateLimit

  # Обновить лимит
  updateCommissionTemplateLimit(
    # ID шаблона
    id: ID!
    input: InputCommissionTemplateLimit!
  ): CommissionTemplateLimit

  # Удалить лимит
  deleteCommissionTemplateLimit(id: ID!): CommissionTemplateLimit

  # Создать компанию
  createCompany(
    # Название компании
    name: String!

    # Email компании
    email: EMAIL!

    # Сайт компании
    url: String!

    # ID страны
    country_id: ID!

    # Телефон
    phone: String
  ): Company

  # Обновить данные компании
  updateCompany(
    # ID компании
    id: ID!

    # Название компании
    name: String

    # Email компании
    email: EMAIL

    # Сайт компании
    url: String

    # Индекс компании
    zip: String

    # Адрес компании
    address: String

    # Город компании
    city: String

    # Регистрационный номер компании
    company_number: String

    # ID страны
    country_id: ID

    # Контактное имя
    contact_name: String

    # Дополнительные поля
    additional_fields_info: [AdditionalFieldInput]

    # Дополнительные поля основные
    additional_fields_basic: [AdditionalFieldInput]

    # Дополнительные поля настройки
    additional_fields_settings: [AdditionalFieldInput]

    # Дополнительные поля данные
    additional_fields_data: [AdditionalFieldInput]

    # Телефон
    phone: String

    # Адрес регистрации
    reg_address: String
    tax_id: String
    incorporate_date: DateTimeUtc

    # Количество сотрудниуов
    employees_id: ID

    # Область деятельности
    type_of_industry_id: ID

    # Номер лицензии
    license_number: String

    # Дата окончания лицензии
    exp_date: DateTimeUtc

    # Состояние
    state_id: ID

    # Причина состояния
    state_reason_id: ID

    # Регистрационный номер
    reg_number: String

    # Тип сущности
    entity_type: String

    # Лого
    logo_id: ID

    # Токен для видеоверификации
    vv_token: String

    # Url верификации мембера
    member_verify_url: String

    # Backoffice login URL
    backoffice_login_url: String

    # Backoffice forgot password URL
    backoffice_forgot_password_url: String

    # Backoffice support URL
    backoffice_support_url: String

    # Backoffice support EMAIL
    backoffice_support_email: EMAIL
  ): Company

  # Удалить компанию
  deleteCompany(id: ID!): Company

  # Добавить модули
  addCompanyModule(
    # ID компании
    company_id: ID!

    # Модуль
    module_id: [ID]

    # Активность
    is_active: Boolean
  ): Company

  # Активировать/деактивировать модуль
  updateCompanyModule(
    id: ID!

    # Активность
    is_active: Boolean!
  ): CompanyModule

  # Удалить модули
  deleteCompanyModule(company_id: ID!): Company

  # Добавить IBAN провайдер к модулю компании
  createCompanyModuleIbanProvider(
    input: InputCompanyModuleIbanProvider!
  ): CompanyModuleIbanProvider

  # Изменить IBAN провайдер
  updateCompanyModuleIbanProvider(
    # ID
    id: ID!

    # Активность
    is_active: Boolean!
  ): CompanyModuleIbanProvider

  # Удалить IBAN провайдер
  deleteCompanyModuleIbanProvider(id: ID!): CompanyModuleIbanProvider

  # Добавить пеймент провайдер к модулю компании
  createCompanyModulePaymentProvider(
    input: InputCompanyModulePaymentProvider!
  ): CompanyModulePaymentProvider

  # Изменить пеймент провайдер
  updateCompanyModulePaymentProvider(
    # ID
    id: ID!

    # Активность
    is_active: Boolean!
  ): CompanyModulePaymentProvider

  # Удалить пеймент провайдер
  deleteCompanyModulePaymentProvider(id: ID!): CompanyModulePaymentProvider

  # Создать департамент
  createDepartment(
    # Название департамента
    name: String!

    # ID компании
    company_id: ID!

    # Массив ID должностей
    department_positions_id: [ID]
  ): Department

  # Изменить название департамента
  updateDepartment(
    # ID департамента
    id: ID!

    # Название департамента
    name: String

    # ID активных должностей
    department_positions_id: [ID]
  ): Department

  # Создание должности
  createDepartmentPosition(
    # Назвние должности
    name: String!

    # ID компании
    company_id: ID!
  ): DepartmentPosition

  # Удалить департамент
  deleteDepartment(id: ID!): Department

  # Удалить должность
  deleteDepartmentPosition(id: ID!): DepartmentPosition

  # Добавить тип документа
  createDocumentType(
    # Название
    name: String!
  ): DocumentType

  # Удалить тип документа
  deleteDocumentType(id: ID!): DocumentType

  # Создать уведомление
  createEmailNotification(
    # Тип Группы
    group_type_id: ID!

    # Тип Group Role
    group_role_id: ID!

    # ID компании
    company_id: ID!

    # ID клиента тип унион
    client_id: Int

    # ID email templates
    templates: [Int]!
  ): EmailNotification

  # Обновить данные уведомления
  updateEmailNotification(
    id: ID!

    # Тип Группы
    group_type_id: ID!

    # Тип Group Role
    group_role_id: ID!

    # ID компании
    company_id: ID

    # ID клиента тип унион
    client_id: Int

    # ID email templates
    templates: [Int]
  ): EmailNotification

  # Удалить запись
  deleteEmailNotification(id: ID!): EmailNotification

  # Создать смтп
  createEmailSmtp(
    name: String!

    # Защита
    security: Securities

    # Имя хоста
    host_name: String!

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String!

    # пароль
    password: String!

    # ответить кому
    replay_to: String

    # Порт
    port: Int!

    # ID компании
    company_id: ID!

    # Определяем отправлять через данные настройки всю почту или нет
    is_sending_mail: Boolean
  ): EmailSmtp

  # Обновить данные смтп
  updateEmailSmtp(
    # Ид шаблона
    id: ID!

    # Защита
    security: Securities

    # Имя хоста
    host_name: String

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String

    # пароль
    password: String

    # ответить кому
    replay_to: String

    # Порт
    port: Int

    # Определяем отправлять через данные настройки всю почту или нет
    is_sending_mail: Boolean
  ): EmailSmtp

  # Удалить запись
  deleteEmailSmtp(
    # ID шаблона
    id: ID!
  ): [EmailSmtp!]!
  sendEmail(
    security: Securities

    # Имя хоста
    host_name: String!

    # От кого
    from_name: String

    # почта
    from_email: String

    # логин
    username: String!

    # пароль
    password: String!

    # ответить кому
    replay_to: String

    # Порт
    port: Int!

    # e-mail
    email: String!
  ): StatusType

  # Создать электронную почту
  createEmailTemplateLayout(
    header: String!

    # Footer электронной почты
    footer: String!

    # Ид компании
    company_id: Int!
  ): EmailTemplateLayout

  # Обновить данные компании
  updateEmailTemplateLayout(
    id: ID!

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String

    # Ид компании
    company_id: Int!
  ): EmailTemplateLayout

  # Удалить запись
  deleteEmailTemplateLayout(id: ID!): EmailTemplateLayout

  # Создать электронную почту
  createEmailTemplate(
    # Название
    name: String!

    # Тема
    subject: String!

    # Взять layout
    use_layout: Boolean!

    # Тип электронной почты
    type: ClientType!

    # Тип сервиса
    service_type: ServiceType!

    # Контент электронной почты
    content: String!

    # Header
    header: String

    # Footer
    footer: String

    # Ид компании
    company_id: ID!
  ): EmailTemplateOnCompanyResponse

  # Обновить данные компании
  updateEmailTemplate(
    id: ID!

    # Тема
    subject: String

    # Взять layout
    use_layout: Boolean

    # Тип электронной почты
    type: ClientType

    # Тип сервиса
    service_type: ServiceType

    # Контент электронной почты
    content: String

    # Header
    header: String

    # Footer
    footer: String

    # Ид компании
    company_id: ID
  ): EmailTemplateOnCompanyResponse

  # Удалить запись
  deleteEmailTemplate(id: ID!): EmailTemplate
  sendEmailWithTemplate(
    # почта
    email: String!

    # Company Id
    company_id: ID!

    # Subject
    subject: String!

    # Content
    content: String

    # Header электронной почты
    header: String

    # Footer электронной почты
    footer: String
  ): StatusType

  # Удалить файл
  deleteFile(id: ID!): Files

  # Создать группу
  createGroupSettings(
    # Название группы
    name: String!

    # Описание группы
    description: String

    # ID роли
    role_id: ID

    # ID типа группы из списка групп поумолчанию
    group_type_id: ID!

    # Провайдер
    providers: [InputGroupRoleProvider]

    # Активная или нет группа (true/false)
    is_active: Boolean

    # ID компании
    company_id: ID

    # ID модуля
    module_id: ID
  ): GroupRole

  # Обновить поля группы
  updateGroupSettings(
    # ID группы
    id: ID!

    # Название группы
    name: String

    # Описание группы
    description: String

    # ID роли
    role_id: ID

    # ID типа группы из списка групп поумолчанию
    group_type_id: ID!

    # Провайдер
    providers: [InputGroupRoleProvider]

    # Активная или нет группа (true/false)
    is_active: Boolean

    # ID компании
    company_id: ID

    # ID модуля
    module_id: ID
  ): GroupRole

  # Удаление группы
  deleteGroup(id: ID!): GroupRole

  # Добавить группу мемберу
  setMemberGroup(
    # Group
    group_type_id: ID!

    # Провайдер
    providers: [InputGroupRoleProvider!]

    # Роль
    role_id: ID!
  ): GroupRole

  # Создать ограничение доступа
  createMemberAccessLimitation(
    input: InputMemberAccessLimitation!
  ): MemberAccessLimitation

  # Обновить ограничение доступа
  updateMemberAccessLimitation(
    # ID шаблона
    id: ID!
    input: InputMemberAccessLimitation!
  ): MemberAccessLimitation

  # Удалить ограничение доступа
  deleteMemberAccessLimitation(
    # ID доступа
    id: ID!
  ): MemberAccessLimitation

  # Обновить профиль пользователя
  updateMemberProfile(
    # Имя
    first_name: String

    # Фамилия
    last_name: String

    # ID Страны
    country_id: ID

    # ID языка
    language_id: ID

    # Email
    email: EMAIL
  ): MemberProfile

  # Отправить письмо с подтверждением смены email
  sendConfirmChangeEmail(
    # Email
    email: String!
  ): StatusType

  # Создать участника
  createMember(
    # Имя участника
    first_name: String!

    # Фамилия участника
    last_name: String!

    # Email участника
    email: EMAIL!

    # Пол участника
    sex: Sex

    # ID компании
    company_id: ID!

    # ID страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID роли участника
    group_id: ID!

    # Статус участника
    member_status_id: ID

    # ID настройки двухфактороной авторизации
    two_factor_auth_setting_id: ID!

    # Пароль участника, если не передан то сгенерируется случайный
    password: String

    # если true видит только своих аппликантов
    is_show_owner_applicants: Boolean

    # Подписывать или нет транзакцию
    is_sign_transaction: Boolean

    # Отправить приглашение на email
    send_email: Boolean
  ): Members

  # Обновить поля участника
  updateMember(
    # ID участника
    id: ID!

    # Имя участника
    first_name: String

    # Фамилия участника
    last_name: String

    # Email участника
    email: EMAIL

    # Пол участника
    sex: Sex

    # ID компании
    company_id: ID

    # ID страны
    country_id: ID

    # ID языка
    language_id: ID

    # ID роли участника
    group_id: ID

    # Статус участника
    member_status_id: ID

    # Активен не активен
    is_active: Boolean

    # ID должности
    department_position_id: ID

    # ID департамента
    department_id: ID

    # ID настройки двухфактороной авторизации
    two_factor_auth_setting_id: ID

    # Блок дополнительных полей
    # в формате:
    # {field_type:Тип поля, field_name: Название дополнительного поля, field_value: Значение поля}
    additional_fields: [AdditionalFieldInput]

    # Дополнительны поля для member info
    additional_info_fields: [AdditionalFieldInput]

    # если true видит только своих аппликантов
    is_show_owner_applicants: Boolean

    # Подписывать или нет транзакцию
    is_sign_transaction: Boolean

    # ip_address
    ip_address: String

    # ID photo
    photo_id: ID

    # Должность
    job_title: String
  ): Members

  # Установить статус Suspended
  setMemberSuspended(id: ID!): Members

  # Установить статус Inactive
  setMemberInactive(id: ID!): Members

  # Установить статус aActive
  setMemberActive(id: ID!): Members

  # Установить пароль участника
  setMemberPassword(
    id: ID!
    password: String!
    password_confirmation: String!
  ): Members

  # Установить PIN участнику
  setMemberSecurityPin(id: ID!): Members

  # Отправить ссылку для подтверждения email
  sendMemberEmailVerification(id: ID!): Members

  # Сбросить пароль участнику
  resetMemberPassword(id: ID!): Members

  # Удалить участника
  deleteMember(
    # ID участника
    id: ID!
  ): Members

  # Создать модуль
  createModule(
    # Название модуля
    name: String!
  ): Module

  # Создать банк
  createPaymentBank(input: InputPaymentBank!): PaymentBank

  # Обновить поля банка
  updatePaymentBank(id: ID!, input: InputPaymentBank!): PaymentBank

  # Удалить платежную систему
  deletePaymentBank(id: ID!): PaymentBank

  # Создать платежный провайдер
  createPaymentProvider(input: InputPaymentProvider!): PaymentProvider

  # Обновить поля платежного провайдера
  updatePaymentProvider(id: ID!, input: InputPaymentProvider!): PaymentProvider

  # Удалить платежный провайдер
  deletePaymentProvider(id: ID!): PaymentProvider

  # Создать
  createPaymentProviderIban(
    input: InputPaymentProviderIban!
  ): PaymentProviderIban

  # Обновить
  updatePaymentProviderIban(
    # ID
    id: ID!
    input: InputPaymentProviderIban!
  ): PaymentProviderIban

  # Удалить
  deletePaymentProviderIban(id: ID!): PaymentProviderIban

  # Создать платежную систему
  createPaymentSystem(input: InputPaymentSystem!): PaymentSystem

  # Обновить поля платежной системы
  updatePaymentSystem(
    # ID платежной системы
    id: ID!
    input: InputPaymentSystem!
  ): PaymentSystem

  # Удалить платежную систему
  deletePaymentSystem(id: ID!): PaymentSystem

  # Создать платеж
  createPayment(
    # Аккаунт
    account_id: ID!

    # Валюта
    currency_id: ID!
    price_list_fees_id: ID!
    recipient_account: String!
    recipient_bank_name: String!
    recipient_bank_address: String!
    recipient_bank_swift: String!
    recipient_bank_country_id: ID!
    beneficiary_name: String!
    beneficiary_state: String!
    beneficiary_country_id: ID!
    beneficiary_address: String!
    beneficiary_city: String!
    beneficiary_zip: String!
    beneficiary_additional_data: JSON

    # Сумма
    amount: Decimal!
    amount_real: Decimal
    fee: Decimal

    # Комиссия
    fee_type_id: ID!

    # Срочность
    urgency_id: ID!

    # Тип
    operation_type_id: ID!

    # Платежный ровайдер
    payment_provider_id: ID!
    respondent_fees_id: ID!

    # Компания
    company_id: ID!
    execution_at: DateTimeUtc
  ): Payments

  # Редактировать платеж
  updatePayment(
    id: ID!

    # Статус
    status_id: ID!
  ): Payments

  # Удалить платеж
  deletePayment(id: ID!): Payments

  # Создать Цен
  createPriceListFees(input: PriceListFeeInput): PriceListFee

  # Обновить данные Цен
  updatePriceListFees(
    id: ID!
    commission_price_list: [priceList]
    input: PriceListFeeInput
  ): PriceListFee

  # Удалить Цен
  deletePriceListFees(
    # ID price list fee
    id: ID!
  ): PriceListFee

  # Создать проект
  createProject(input: InputProject!): Project

  # Обновить проект
  updateProject(
    # ID проекта
    id: ID!
    input: InputProject!
  ): Project

  # Удалить проект
  deleteProject(
    # ID проекта
    id: ID!
  ): Project

  # Изменить настройки api проекта
  updateProjectApiSetting(
    project_id: ID!
    input: [InputProjectApiSetting!]!
  ): [ProjectApiSetting!]!
  createRegion(input: InputRegion!): Region
  updateRegion(
    # ID региона
    id: ID!
    input: InputRegion!
  ): Region
  deleteRegion(
    # ID региона
    id: ID!
  ): Region
  createRole(
    # Название роли
    name: String!

    # Описание
    description: String

    # Массив разрешений
    permissions: [ID]

    # Тип группы
    group_type_id: ID

    # ID компании
    company_id: ID

    # ID группы полномочий Применить ко всем компаниям
    permission_category_all_member: [ID]
  ): Role
  updateRole(
    # ID роли
    id: ID!

    # Название роли
    name: String!

    # Описание роли
    description: String

    # Массив разрешений
    permissions: [ID]

    # Тип группы
    group_type_id: ID

    # ID компании
    company_id: ID

    # ID группы полномочий Применить ко всем компаниям
    permission_category_all_member: [ID]
  ): Role
  deleteRole(
    # ID роли
    id: ID!
  ): Role

  # Создать комментарии
  createTicketComment(
    # Сообщение
    message: String!

    # ID билета
    ticket_id: ID!

    # ID клиента
    client_id: ID!
  ): TicketComments

  # Создать компанию
  createTicket(
    # Название билета
    title: String!

    # Message билета
    message: String!

    # Статус билета
    status: Int

    # ID мембера
    member_id: ID!

    # ID клиента
    client_id: ID!
  ): Ticket

  # Обновить данные компании
  updateTicket(
    id: ID!

    # Название билета
    title: String

    # Message билета
    message: String

    # Статус билета
    status: Int
  ): Ticket

  # Создать исходящий перевод
  createTransferOutgoing(
    # ID компании
    company_id: ID!

    # ID группы
    group_id: ID!

    # ID типа группы
    group_type_id: ID!

    # ID проекта
    project_id: ID!

    # Сумма
    amount: Decimal!

    # ID валюты
    currency_id: ID!

    # ID аккаунта
    account_id: ID!

    # ID платежного провайдера
    payment_provider_id: ID!

    # ID платежной системы
    payment_system_id: ID!

    # ID банка получателя
    recipient_bank_country_id: ID!
    requested_by_id: ID!
    price_list_id: ID!
    price_list_fee_id: ID!
    execution_at: DateTimeUtc

    # Номер счета или IBAN получателя
    recipient_account: String

    # Имя банка получателя
    recipient_bank_name: String

    # Адрес банка получателя
    recipient_bank_address: String

    # SWIFT банка получателя
    recipient_bank_swift: String

    # Имя получателя
    recipient_name: String

    # Город получателя
    recipient_city: String

    # Адрес получателя
    recipient_address: String

    # Штат получателя
    recipient_state: String

    # Индекс получателя
    recipient_zip: String

    # Сообщение банка
    bank_message: String

    # ID файлов
    file_id: [ID]
  ): TransferOutgoing

  # Редактировать исходящий перевод
  updateTransferOutgoing(
    # ID
    id: ID!

    # Статус
    status_id: Int!
  ): TransferOutgoing

  # Создать исходящий Fee перевод
  createTransferOutgoingFee(
    # ID компании
    company_id: ID!

    # ID группы
    group_id: ID!

    # ID типа группы
    group_type_id: ID!

    # ID проекта
    project_id: ID!

    # Сумма
    amount: Decimal!

    # ID валюты
    currency_id: ID!

    # ID аккаунта
    account_id: ID!

    # ID типа операции
    operation_type_id: ID!

    # ID платежного провайдера
    payment_provider_id: ID!

    # ID платежной системы
    payment_system_id: ID!

    # ID банка получателя
    recipient_bank_country_id: ID!
    requested_by_id: ID!
    price_list_id: ID!
    price_list_fee_id: ID!
    execution_at: DateTimeUtc

    # Номер счета или IBAN получателя
    recipient_account: String

    # Имя банка получателя
    recipient_bank_name: String

    # Адрес банка получателя
    recipient_bank_address: String

    # SWIFT банка получателя
    recipient_bank_swift: String

    # Имя получателя
    recipient_name: String

    # Город получателя
    recipient_city: String

    # Адрес получателя
    recipient_address: String

    # Штат получателя
    recipient_state: String

    # Индекс получателя
    recipient_zip: String

    # Сообщение банка
    bank_message: String

    # ID файлов
    file_id: [ID]
  ): TransferOutgoing

  # Редактировать исходящий FEE перевод
  updateTransferOutgoingFee(
    # ID
    id: ID!

    # Сумма
    amount: Decimal!

    # Причина
    reason: String

    # ID файлов
    file_id: [ID]
  ): TransferOutgoing

  # Отменить исходящий FEE перевод
  cancelTransferOutgoingFee(id: ID!): TransferOutgoing

  # Регистрация частного пользователя
  createApplicant(
    # Имя
    first_name: String!

    # Фамилия
    last_name: String!

    # email
    email: EMAIL!

    # Телефон
    phone: String!

    # Тип клиента
    client_type: ApplicantClientType!

    # Название компании
    company_name: String

    # URL сайта компании
    url: String

    # Пароль
    password: String!

    # Подтверждение пароля
    password_confirmation: String!
  ): ApplicantSettingsProfile

  # Изменение аккаунта
  updateApplicantAccount(
    # ID
    id: ID!

    # Показать на главной
    is_show: Boolean!
  ): ApplicantAccount!

  # Изменение устройства
  updateApplicantDevice(
    # ID
    id: ID!

    # Доверенное устройство
    trusted: Boolean!
  ): TwoFactorAuthToken!

  # Подтверждение изменения устройства c OTP
  updateApplicantDeviceWithOtp(
    # Код
    code: String!

    # Токен
    auth_token: String!

    # ID
    id: ID!

    # Доверенное устройство
    trusted: Boolean!
  ): ApplicantDevice!

  # Удалить устройство
  deleteApplicantDevice(id: ID!): ApplicantDevice

  # Обновить профиль пользователя
  updateApplicantProfile(
    # Штат / область
    state: String

    # Город
    city: String

    # Адрес
    address: String

    # Индекс
    zip: String

    # ID photo
    photo_id: ID

    # Оповещения об устройствах на email
    notify_device_email: Boolean
  ): ApplicantProfile

  # Установить пароль
  setApplicantSettingsPassword(
    # новый пароль
    password: String!

    # подтверждение пароля
    password_confirmation: String!

    # текущий пароль
    current_password: String!
  ): TwoFactorAuthToken

  # Установить пароль c OTP
  setApplicantSettingsPasswordWithOtp(
    # код
    code: String!

    # токен
    auth_token: String!

    # новый пароль
    password: String!

    # подтверждение пароля
    password_confirmation: String!

    # текущий пароль
    current_password: String!
  ): ApplicantSettingsProfile
}

input InputAccount {
  # ID компании
  company_id: ID!

  # ID валюты
  currency_id: ID!

  # ID владельца
  owner_id: ID!

  # Номер аккаунта
  account_number: String

  # ID провайдера
  payment_provider_id: ID!

  # ID провайдера iban
  iban_provider_id: ID

  # ID шаблона комиссии
  commission_template_id: ID!

  # Имя аккаунта
  account_name: String!

  # Основной или нет
  is_primary: Boolean

  # ID групроле
  group_role_id: ID!

  # ID группы
  group_type_id: ID!

  # ID платежной системы
  payment_system_id: ID!

  # ID банка
  payment_bank_id: ID

  # clientable
  clientableAttach: PivotTable

  # лимит максимального баланса
  min_limit_balance: Decimal

  # лимит минимального баланса
  max_limit_balance: Decimal
}

input PivotTable {
  sync: [ID]
}

type AccountGenerateIbanResponse {
  status: String!
  message: String!
}

type ActiveSessionMutatorResponse {
  status: String!
  message: String!
}

# Дополнительные поля
input AdditionalFieldInput {
  field_name: String
  field_value: StringInteger
  field_type: FieldTypes
}

# String or Integer type
scalar StringInteger

# Типы полей
enum FieldTypes {
  # Тип поля строка
  Text

  # Тип поля текстовое поле
  TextArea

  # ID страны
  CountryList
}

input InputCommissionTemplate {
  # Название шаблона
  name: String!

  # Описание шаблона
  description: String

  # Активен или нет
  is_active: Boolean

  # ID платежного провайдера
  payment_provider_id: ID

  # ID платежной системы
  payment_system_id: [ID]

  # массив ID бизнесов
  business_activity: [ID]

  # массив ID регионов
  region_id: [ID]

  # массив ID валют
  currency_id: [ID]

  # массив ID лимитов
  commission_template_limit_id: [ID]

  # ID компании
  company_id: ID
}

input InputCommissionTemplateLimit {
  # ID типа лимита
  commission_template_limit_type_id: ID!

  # ID направления платежа
  commission_template_limit_transfer_direction_id: ID!

  # Сумма лимита
  amount: Decimal!

  # ID валюты лимита
  currency_id: ID

  # ID периода лимита
  commission_template_limit_period_id: ID

  # ID события лимита
  commission_template_limit_action_type_id: ID

  # ID количество срабатываний лимита
  period_count: ID

  # ID шаблона комиссии
  commission_template_id: ID!

  # ID региона
  region_id: ID
}

input InputCompanyModuleIbanProvider {
  # ID модуля компании
  company_module_id: ID

  # ID IBAN провайдера
  payment_provider_iban_id: ID

  # Активность
  is_active: Boolean
}

input InputCompanyModulePaymentProvider {
  # ID модуля компании
  company_module_id: ID

  # ID платежного провайдера
  payment_provider_id: ID

  # Активность
  is_active: Boolean
}

type EmailTemplateOnCompanyResponse {
  layout: EmailTemplateLayout
  data: [EmailTemplate!]!
}

input InputGroupRoleProvider {
  # ID платежного провайдера
  payment_provider_id: ID!

  # ID шаблона комиссий
  commission_template_id: ID!

  # По умолчанию
  is_default: Boolean
}

input InputMemberAccessLimitation {
  # ID Мембера
  member_id: ID!

  # ID Груп Роль
  groupRoles: PivotTable

  # ID Груп type
  group_type_id: ID

  # ID компании
  company_id: ID!

  # ID модуля
  module_id: ID!

  # ID проекта
  project_id: ID

  # ID платежного провайдера
  payment_provider_id: ID

  # Показать только своих аппликантов
  see_own_applicants: Boolean
}

input InputPaymentBank {
  # Название банка
  name: String!

  # Адрес банка
  address: String!

  # Код банка
  bank_code: String

  # Код платежной системы
  payment_system_code: String

  # ID страны
  country_id: ID!

  # ID платежного системы
  payment_system_id: ID!

  # ID платежного провидера
  payment_provider_id: ID!

  # Активный не активный (true/false)
  is_active: Boolean
}

input InputPaymentProvider {
  # Название провайдера
  name: String!

  # Описание провайдера
  description: String

  # Лого
  logo_id: ID

  # Активен или нет
  is_active: Boolean

  # Ид компании
  company_id: ID!

  # массив ID платежных систем
  payment_systems: [ID]
}

input InputPaymentProviderIban {
  # Название
  name: String!

  # ID компании
  company_id: ID!

  # ID валюты
  currency_id: ID!

  # Активность
  is_active: Boolean!
}

input InputPaymentSystem {
  # Название платежной системы
  name: String!

  # Активный не активный (true/false)
  is_active: Boolean

  # массив ID стран
  regions: PivotTable

  # массив ID валют
  currencies: PivotTable

  # массив ID провайдеров
  payment_provider_id: ID

  # массив ID Реквизитов
  banks: PivotTable

  # массив типов операций
  operations: PivotTable

  # Описание
  description: String

  # Лого
  logo_id: ID
}

input PriceListFeeInput {
  name: String!
  type_id: ID!
  operation_type_id: ID!
  period_id: ID
  price_list_id: ID!
  fee_ranges: JSON
  fees: [PriceListFeesList!]
  scheduled: PriceListFeeScheduledInput
}

input PriceListFeesList {
  currency_id: ID!
  fee: [[PriceListFeeItem]!]!
}

input PriceListFeeItem {
  mode: String!
  fee: Int
  amount_from: Int
  amount_to: Int
  percent: Int
}

input PriceListFeeScheduledInput {
  starting_date: DateTimeUtc
  end_date: DateTimeUtc
  recurrent_interval: Int
  starting_date_id: ID
  end_date_id: ID
}

input priceList {
  payment_system_id: ID
  commission_template_id: ID
  payment_provider_id: ID
  company_id: ID
}

input InputProject {
  # Название
  name: String!

  # URL
  url: String

  # Описание
  description: String

  # Email поддержки
  support_email: String

  # URL входа
  login_url: String

  # Имя отправителя SMS
  sms_sender_name: String

  # URL клиента
  client_url: String

  # URL восстановления пароля
  forgot_password_url: String

  # Компания
  company_id: ID!

  # Модуль
  module_id: ID!

  # Аватар
  avatar_id: ID

  # Состояние
  state_id: ID

  # Настройки
  project_settings: [InputProjectSettings]

  # Дополнительные поля
  additional_fields_basic: [AdditionalFieldInput]

  # Дополнительные поля настройки
  additional_fields_settings: [AdditionalFieldInput]
}

input InputProjectSettings {
  group_type_id: ID
  group_role_id: ID
  commission_template_id: ID
  payment_provider_id: ID
  iban_provider_id: ID
  applicant_type: ApplicantType!
}

input InputProjectApiSetting {
  # Кошелек
  wallet: String!

  # API ключ
  api_key: String!

  # Пароль
  password: String!

  # is_active
  is_active: Boolean

  # payment_provider_id
  provider_id: ID!

  # payment_provider_type
  provider_type: ProviderTypeEnum!
}

enum ProviderTypeEnum {
  PaymentProvider
  PaymentProviderIban
}

input InputRegion {
  # Название региона
  name: String!

  # Массив стран
  countries: PivotTable

  # ID компании
  company_id: ID!
}

enum ApplicantClientType {
  Private
  Corporate
}

type ApplicantSettingsProfile {
  id: ID!

  # Имя
  first_name: String

  # Фамилия
  last_name: String

  # Отчество
  middle_name: String

  # email
  email: EMAIL
  email_confirm_url: String
}

type TwoFactorAuthToken {
  two_factor: Boolean
  auth_token: String
}

# DocumentStateEnum
enum DocumentStateEnum {
  # 1
  Pending

  # 2
  Processing

  # 3
  Approve

  # 4
  Declined
}

scalar DateEnd

scalar DateTime

input DateRange {
  from: Date!
  to: DateEnd!
}

input ImageableMorphToTable {
  connect: ConnectImageableInput
  disconnect: Boolean
  delete: Boolean
}

input ConnectImageableInput {
  type: String!
  id: ID!
}

enum AccountClientsType {
  INDIVIDUAL
  COMPANY
}

input QueryClientCondition {
  id: ID!
}

input QueryApplicantIndividualModulesFilterStatic {
  applicant_individual_id: ID
}

type Groups {
  id: ID!

  # Название группы
  name: GroupsEntities!
  groups: [GroupRole] @deprecated
}

enum TransferType {
  INCOMING
  OUTGOING
}

enum OperationTypeEnum {
  INCOMING_WIRE_TRANSFER
  OUTGOING_WIRE_TRANSFER
  BETWEEN_ACCOUNT
  BETWEEN_USERS
  EXCHANGE
  DEBIT
  CREDIT
  SCHEDULED_FEES
}

type PermissionCategoryRole {
  permission_category_id: ID
  role_id: ID
  is_all_companies: Boolean
}

# Column names for Query.grantedBankingAccess.filter.
enum QueryGrantedBankingAccessFilterStaticOperator {
  member_id
  grant_access
}

# Column names for Query.grantedBankingAccess.filter.
enum QueryGrantedBankingAccessFilterStaticType {
  member_id
  grant_access
}

# Input column names for Query.grantedBankingAccess.filter.
input QueryGrantedBankingAccessFilterStaticInput {
  member_id: ID
  grant_access: Boolean
}

# Column names for Query.applicantBankingAccesses.filter.
enum QueryApplicantBankingAccessesFilterStaticOperator {
  member_id
  grant_access
}

# Column names for Query.applicantBankingAccesses.filter.
enum QueryApplicantBankingAccessesFilterStaticType {
  member_id
  grant_access
}

# Input column names for Query.applicantBankingAccesses.filter.
input QueryApplicantBankingAccessesFilterStaticInput {
  member_id: ID
  grant_access: Boolean
}

# Column names for Query.getMatchedUsers.filter.
enum QueryGetMatchedUsersFilterStaticOperator {
  applicant_type
}

# Column names for Query.getMatchedUsers.filter.
enum QueryGetMatchedUsersFilterStaticType {
  applicant_type
}

# Input column names for Query.getMatchedUsers.filter.
input QueryGetMatchedUsersFilterStaticInput {
  applicant_type: ApplicantType
}

# Column names for Query.getMatchedUsers.filter.
enum QueryGetMatchedUsersFilterStaticEnumApplicantType {
  APPLICANT_INDIVIDUAL
  APPLICANT_COMPANY
}

# Column names for Query.emailTemplates.filter.
enum QueryEmailTemplatesFilterStaticOperator {
  hasCompanyFilterByName
  name
  company_id
  type
  service_type
}

# Column names for Query.emailTemplates.filter.
enum QueryEmailTemplatesFilterStaticType {
  hasCompanyFilterByName
  name
  company_id
  type
  service_type
}

# Input column names for Query.emailTemplates.filter.
input QueryEmailTemplatesFilterStaticInput {
  hasCompanyFilterByName: String
  name: String
  company_id: ID
  type: ClientType
  service_type: ServiceType
}

# Column names for Query.emailTemplates.filter.
enum QueryEmailTemplatesFilterStaticEnumClientType {
  ADMINISTRATION
  CLIENT
}

# Column names for Query.emailTemplates.filter.
enum QueryEmailTemplatesFilterStaticEnumServiceType {
  BANKING_COMMON
  BANKING_SYSTEM
  BANKING
  COMMON
  SYSTEM
  ADMIN_NOTIFY
}

# Column names for Query.feeTypes.filter.
enum QueryFeeTypesFilterStaticOperator {
  hasOperationTypeFilterById
}

# Column names for Query.feeTypes.filter.
enum QueryFeeTypesFilterStaticType {
  hasOperationTypeFilterById
}

# Input column names for Query.feeTypes.filter.
input QueryFeeTypesFilterStaticInput {
  hasOperationTypeFilterById: ID
}

# Column names for Query.group_types.filter.
enum QueryGroupTypesFilterStaticOperator {
  hasGroupsFilterByCompanyId
  hasGroupsFilterByRoleId
  hasRolesFilterById
}

# Column names for Query.group_types.filter.
enum QueryGroupTypesFilterStaticType {
  hasGroupsFilterByCompanyId
  hasGroupsFilterByRoleId
  hasRolesFilterById
}

# Input column names for Query.group_types.filter.
input QueryGroupTypesFilterStaticInput {
  hasGroupsFilterByCompanyId: ID
  hasGroupsFilterByRoleId: ID
  hasRolesFilterById: ID
}

# Column names for Query.operationTypes.filter.
enum QueryOperationTypesFilterStaticOperator {
  fee_type_id
  transfer_type
  payment_system_id
}

# Column names for Query.operationTypes.filter.
enum QueryOperationTypesFilterStaticType {
  fee_type_id
  transfer_type
  payment_system_id
}

# Input column names for Query.operationTypes.filter.
input QueryOperationTypesFilterStaticInput {
  fee_type_id: ID
  transfer_type: TransferType
  payment_system_id: ID
}

# Column names for Query.operationTypes.filter.
enum QueryOperationTypesFilterStaticEnumTransferType {
  INCOMING
  OUTGOING
}

# Column names for Query.paymentStatuses.filter.
enum QueryPaymentStatusesFilterStaticOperator {
  operation_type
}

# Column names for Query.paymentStatuses.filter.
enum QueryPaymentStatusesFilterStaticType {
  operation_type
}

# Input column names for Query.paymentStatuses.filter.
input QueryPaymentStatusesFilterStaticInput {
  operation_type: OperationTypeEnum
}

# Column names for Query.paymentStatuses.filter.
enum QueryPaymentStatusesFilterStaticEnumOperationTypeEnum {
  INCOMING_TRANSFER
  OUTGOING_TRANSFER
  BETWEEN_ACCOUNT
  BETWEEN_USERS
  EXCHANGE
  DEBIT
  CREDIT
  SCHEDULED_FEE
}

# Column names for Query.priceListFees.filter.
enum QueryPriceListFeesFilterStaticOperator {
  id
  price_list_id
  type_id
  operation_type_id
  period_id
  hasCompanyFilterById
  hasPaymentProviderFilterById
  hasPaymentSystemFilterById
  hasFeesFilterById
}

# Column names for Query.priceListFees.filter.
enum QueryPriceListFeesFilterStaticType {
  id
  price_list_id
  type_id
  operation_type_id
  period_id
  hasCompanyFilterById
  hasPaymentProviderFilterById
  hasPaymentSystemFilterById
  hasFeesFilterById
}

# Input column names for Query.priceListFees.filter.
input QueryPriceListFeesFilterStaticInput {
  id: ID
  price_list_id: ID
  type_id: ID
  operation_type_id: ID
  period_id: ID
  hasCompanyFilterById: ID
  hasPaymentProviderFilterById: ID
  hasPaymentSystemFilterById: ID
  hasFeesFilterById: ID
}

# Column names for Query.requisites.filter.
enum QueryRequisitesFilterStaticOperator {
  company_id
  payment_provider_id
  payment_system_id
  payment_bank_id
  account_number
}

# Column names for Query.requisites.filter.
enum QueryRequisitesFilterStaticType {
  company_id
  payment_provider_id
  payment_system_id
  payment_bank_id
  account_number
}

# Input column names for Query.requisites.filter.
input QueryRequisitesFilterStaticInput {
  company_id: ID
  payment_provider_id: ID
  payment_system_id: ID
  payment_bank_id: ID
  account_number: String
}

# Column names for Query.applicantAccounts.filter.
enum QueryApplicantAccountsFilterStaticOperator {
  is_show
}

# Column names for Query.applicantAccounts.filter.
enum QueryApplicantAccountsFilterStaticType {
  is_show
}

# Input column names for Query.applicantAccounts.filter.
input QueryApplicantAccountsFilterStaticInput {
  is_show: Boolean
}

# Column names for Query.accountLimits.filter.
enum QueryAccountLimitsFilterStaticOperator {
  hasCurrencyMixedIdOrName
  hasCommissionTemplateLimitTypeMixedIdOrName
  hasCommissionTemplateLimitTransferDirectionMixedIdOrName
  hasCommissionTemplateLimitPeriodMixedIdOrName
  hasCommissionTemplateLimitActionTypeMixedIdOrName
  account_id
  period_count
}

# Column names for Query.accountLimits.filter.
enum QueryAccountLimitsFilterStaticType {
  hasCurrencyMixedIdOrName
  hasCommissionTemplateLimitTypeMixedIdOrName
  hasCommissionTemplateLimitTransferDirectionMixedIdOrName
  hasCommissionTemplateLimitPeriodMixedIdOrName
  hasCommissionTemplateLimitActionTypeMixedIdOrName
  account_id
  period_count
}

# Input column names for Query.accountLimits.filter.
input QueryAccountLimitsFilterStaticInput {
  hasCurrencyMixedIdOrName: Mixed
  hasCommissionTemplateLimitTypeMixedIdOrName: Mixed
  hasCommissionTemplateLimitTransferDirectionMixedIdOrName: Mixed
  hasCommissionTemplateLimitPeriodMixedIdOrName: Mixed
  hasCommissionTemplateLimitActionTypeMixedIdOrName: Mixed
  account_id: ID
  period_count: ID
}

# Column names for Query.accountReachedLimits.filter.
enum QueryAccountReachedLimitsFilterStaticOperator {
  account_id
  limit_currency
  limit_type
  limit_value
  transfer_direction
  period
  amount
}

# Column names for Query.accountReachedLimits.filter.
enum QueryAccountReachedLimitsFilterStaticType {
  account_id
  limit_currency
  limit_type
  limit_value
  transfer_direction
  period
  amount
}

# Input column names for Query.accountReachedLimits.filter.
input QueryAccountReachedLimitsFilterStaticInput {
  account_id: ID
  limit_currency: String
  limit_type: String
  limit_value: String
  transfer_direction: String
  period: Int
  amount: Float
}

# Column names for Query.accountList.filter.
enum QueryAccountListFilterStaticOperator {
  hasCompanyMixedIdOrName
  hasPaymentProviderMixedIdOrName
  hasPaymentSystemMixedIdOrName
  hasOwnerMixedIdOrFullname
  MixedAccountNumberOrAccountName
  currency_id
  hasGroupRoleMixedIdOrName
  group_type_id
  hasMemberMixedIdOrFullname
  is_primary
  hasCommissionTemplateMixedIdOrFullname
  account_state_id
  hasClientableMixedIdOrFullname
}

# Column names for Query.accountList.filter.
enum QueryAccountListFilterStaticType {
  hasCompanyMixedIdOrName
  hasPaymentProviderMixedIdOrName
  hasPaymentSystemMixedIdOrName
  hasOwnerMixedIdOrFullname
  MixedAccountNumberOrAccountName
  currency_id
  hasGroupRoleMixedIdOrName
  group_type_id
  hasMemberMixedIdOrFullname
  is_primary
  hasCommissionTemplateMixedIdOrFullname
  account_state_id
  hasClientableMixedIdOrFullname
}

# Input column names for Query.accountList.filter.
input QueryAccountListFilterStaticInput {
  hasCompanyMixedIdOrName: Mixed
  hasPaymentProviderMixedIdOrName: Mixed
  hasPaymentSystemMixedIdOrName: Mixed
  hasOwnerMixedIdOrFullname: Mixed
  MixedAccountNumberOrAccountName: String
  currency_id: ID
  hasGroupRoleMixedIdOrName: Mixed
  group_type_id: ID
  hasMemberMixedIdOrFullname: Mixed
  is_primary: Boolean
  hasCommissionTemplateMixedIdOrFullname: Mixed
  account_state_id: ID
  hasClientableMixedIdOrFullname: Mixed
}

# Column names for Query.applicantIndividuals.filter.
enum QueryApplicantIndividualsFilterStaticOperator {
  id
  fullname
  email
  company_id
  project_id
  kyc_level_id
  hasRiskLevelFilterById
  hasStateReasonFilterById
  hasStatusFilterById
  hasGroupRoleMixedIdOrName
  hasModulesFilterById
}

# Column names for Query.applicantIndividuals.filter.
enum QueryApplicantIndividualsFilterStaticType {
  id
  fullname
  email
  company_id
  project_id
  kyc_level_id
  hasRiskLevelFilterById
  hasStateReasonFilterById
  hasStatusFilterById
  hasGroupRoleMixedIdOrName
  hasModulesFilterById
}

# Input column names for Query.applicantIndividuals.filter.
input QueryApplicantIndividualsFilterStaticInput {
  id: ID
  fullname: String
  email: String
  company_id: ID
  project_id: ID
  kyc_level_id: ID
  hasRiskLevelFilterById: ID
  hasStateReasonFilterById: ID
  hasStatusFilterById: ID
  hasGroupRoleMixedIdOrName: Mixed
  hasModulesFilterById: ID
}

# Column names for Query.applicantCompanies.filter.
enum QueryApplicantCompaniesFilterStaticOperator {
  id
  company_id
  project_id
  account_manager_member_id
  hasStateReasonMixedIdOrName
  hasGroupRoleMixedIdOrName
  hasRiskLevelMixedIdOrName
  hasStatusMixedIdOrName
  hasBusinessTypeMixedIdOrName
  hasOwnerMixedIdOrFullname
  hasKycLevelMixedIdOrName
  hasStatusFilterById
  hasModulesFilterById
  name
  url
  email
}

# Column names for Query.applicantCompanies.filter.
enum QueryApplicantCompaniesFilterStaticType {
  id
  company_id
  project_id
  account_manager_member_id
  hasStateReasonMixedIdOrName
  hasGroupRoleMixedIdOrName
  hasRiskLevelMixedIdOrName
  hasStatusMixedIdOrName
  hasBusinessTypeMixedIdOrName
  hasOwnerMixedIdOrFullname
  hasKycLevelMixedIdOrName
  hasStatusFilterById
  hasModulesFilterById
  name
  url
  email
}

# Input column names for Query.applicantCompanies.filter.
input QueryApplicantCompaniesFilterStaticInput {
  id: ID
  company_id: ID
  project_id: ID
  account_manager_member_id: ID
  hasStateReasonMixedIdOrName: Mixed
  hasGroupRoleMixedIdOrName: Mixed
  hasRiskLevelMixedIdOrName: Mixed
  hasStatusMixedIdOrName: Mixed
  hasBusinessTypeMixedIdOrName: Mixed
  hasOwnerMixedIdOrFullname: Mixed
  hasKycLevelMixedIdOrName: Mixed
  hasStatusFilterById: ID
  hasModulesFilterById: ID
  name: String
  url: String
  email: String
}

# Column names for Query.applicantCompanyRiskLevelHistory.filter.
enum QueryApplicantCompanyRiskLevelHistoryFilterStaticRequired {
  applicant_company_id
}

# Column names for Query.applicantCompanyRiskLevelHistory.filter.
enum QueryApplicantCompanyRiskLevelHistoryFilterStaticOperator {
  applicant_company_id
  risk_level_id
}

# Column names for Query.applicantCompanyRiskLevelHistory.filter.
enum QueryApplicantCompanyRiskLevelHistoryFilterStaticType {
  applicant_company_id
  risk_level_id
}

# Input column names for Query.applicantCompanyRiskLevelHistory.filter.
input QueryApplicantCompanyRiskLevelHistoryFilterStaticInput {
  applicant_company_id: ID!
  risk_level_id: ID
}

# Column names for Query.applicantDocuments.filter.
enum QueryApplicantDocumentsFilterStaticOperator {
  id
  applicant_id
  document_type_id
  document_state_id
}

# Column names for Query.applicantDocuments.filter.
enum QueryApplicantDocumentsFilterStaticType {
  id
  applicant_id
  document_type_id
  document_state_id
}

# Input column names for Query.applicantDocuments.filter.
input QueryApplicantDocumentsFilterStaticInput {
  id: ID
  applicant_id: ID
  document_type_id: ID
  document_state_id: ID
}

# Column names for Query.applicantDocumentTags.filter.
enum QueryApplicantDocumentTagsFilterStaticOperator {
  name
  hasCategoryFilterByName
}

# Column names for Query.applicantDocumentTags.filter.
enum QueryApplicantDocumentTagsFilterStaticType {
  name
  hasCategoryFilterByName
}

# Input column names for Query.applicantDocumentTags.filter.
input QueryApplicantDocumentTagsFilterStaticInput {
  name: String
  hasCategoryFilterByName: String
}

# Column names for Query.applicantIndividualCompanyPositions.filter.
enum QueryApplicantIndividualCompanyPositionsFilterStaticOperator {
  name
  company_id
}

# Column names for Query.applicantIndividualCompanyPositions.filter.
enum QueryApplicantIndividualCompanyPositionsFilterStaticType {
  name
  company_id
}

# Input column names for Query.applicantIndividualCompanyPositions.filter.
input QueryApplicantIndividualCompanyPositionsFilterStaticInput {
  name: String
  company_id: ID
}

# Column names for Query.applicantIndividualCompanyRelations.filter.
enum QueryApplicantIndividualCompanyRelationsFilterStaticOperator {
  name
  company_id
}

# Column names for Query.applicantIndividualCompanyRelations.filter.
enum QueryApplicantIndividualCompanyRelationsFilterStaticType {
  name
  company_id
}

# Input column names for Query.applicantIndividualCompanyRelations.filter.
input QueryApplicantIndividualCompanyRelationsFilterStaticInput {
  name: String
  company_id: ID
}

# Column names for Query.bankCorrespondents.filter.
enum QueryBankCorrespondentsFilterStaticOperator {
  name
  hasBankCorrespondentCurrenciesFilterByCurrencyId
  hasBankCorrespondentRegionsFilterByRegionId
}

# Column names for Query.bankCorrespondents.filter.
enum QueryBankCorrespondentsFilterStaticType {
  name
  hasBankCorrespondentCurrenciesFilterByCurrencyId
  hasBankCorrespondentRegionsFilterByRegionId
}

# Input column names for Query.bankCorrespondents.filter.
input QueryBankCorrespondentsFilterStaticInput {
  name: String
  hasBankCorrespondentCurrenciesFilterByCurrencyId: ID
  hasBankCorrespondentRegionsFilterByRegionId: ID
}

# Column names for Query.businessActivities.filter.
enum QueryBusinessActivitiesFilterStaticOperator {
  id
  name
  hasCommissionTemplateFilterById
}

# Column names for Query.businessActivities.filter.
enum QueryBusinessActivitiesFilterStaticType {
  id
  name
  hasCommissionTemplateFilterById
}

# Input column names for Query.businessActivities.filter.
input QueryBusinessActivitiesFilterStaticInput {
  id: ID
  name: String
  hasCommissionTemplateFilterById: ID
}

# Column names for Query.commissionPriceLists.filter.
enum QueryCommissionPriceListsFilterStaticOperator {
  hasPaymentProviderFilterById
  hasCommissionTemplateFilterById
  hasPaymentSystemFilterById
  id
  company_id
  region_id
}

# Column names for Query.commissionPriceLists.filter.
enum QueryCommissionPriceListsFilterStaticType {
  hasPaymentProviderFilterById
  hasCommissionTemplateFilterById
  hasPaymentSystemFilterById
  id
  company_id
  region_id
}

# Input column names for Query.commissionPriceLists.filter.
input QueryCommissionPriceListsFilterStaticInput {
  hasPaymentProviderFilterById: ID
  hasCommissionTemplateFilterById: ID
  hasPaymentSystemFilterById: ID
  id: ID
  company_id: ID
  region_id: ID
}

# Column names for Query.commissionTemplates.filter.
enum QueryCommissionTemplatesFilterStaticOperator {
  id
  name
  is_active
  hasCompanyFilterById
  hasPaymentProviderFilterById
  hasBusinessActivityFilterById
}

# Column names for Query.commissionTemplates.filter.
enum QueryCommissionTemplatesFilterStaticType {
  id
  name
  is_active
  hasCompanyFilterById
  hasPaymentProviderFilterById
  hasBusinessActivityFilterById
}

# Input column names for Query.commissionTemplates.filter.
input QueryCommissionTemplatesFilterStaticInput {
  id: ID
  name: String
  is_active: Boolean
  hasCompanyFilterById: ID
  hasPaymentProviderFilterById: ID
  hasBusinessActivityFilterById: ID
}

# Column names for Query.companies.filter.
enum QueryCompaniesFilterStaticOperator {
  name
  email
  url
  reg_number
  entity_type
  country_id
  hasPaymentProvidersFilterById
  hasPaymentSystemFilterById
  hasRegionsFilterById
}

# Column names for Query.companies.filter.
enum QueryCompaniesFilterStaticType {
  name
  email
  url
  reg_number
  entity_type
  country_id
  hasPaymentProvidersFilterById
  hasPaymentSystemFilterById
  hasRegionsFilterById
}

# Input column names for Query.companies.filter.
input QueryCompaniesFilterStaticInput {
  name: String
  email: String
  url: String
  reg_number: String
  entity_type: String
  country_id: ID
  hasPaymentProvidersFilterById: ID
  hasPaymentSystemFilterById: ID
  hasRegionsFilterById: ID
}

# Column names for Query.departments.filter.
enum QueryDepartmentsFilterStaticOperator {
  hasCompanyFilterById
  name
}

# Column names for Query.departments.filter.
enum QueryDepartmentsFilterStaticType {
  hasCompanyFilterById
  name
}

# Input column names for Query.departments.filter.
input QueryDepartmentsFilterStaticInput {
  hasCompanyFilterById: ID
  name: String
}

# Column names for Query.departmentPositions.filter.
enum QueryDepartmentPositionsFilterStaticOperator {
  hasDepartmentFilterById
  name
  is_active
}

# Column names for Query.departmentPositions.filter.
enum QueryDepartmentPositionsFilterStaticType {
  hasDepartmentFilterById
  name
  is_active
}

# Input column names for Query.departmentPositions.filter.
input QueryDepartmentPositionsFilterStaticInput {
  hasDepartmentFilterById: ID
  name: String
  is_active: Boolean
}

# Column names for Query.emailNotifications.filter.
enum QueryEmailNotificationsFilterStaticOperator {
  company_id
  type
  recipient_type
  hasApplicantIndividualMixedIdOrFullname
  hasApplicantCompanyMixedIdOrName
  hasGroupRoleMixedIdOrName
  hasMemberMixedIdOrFullname
  hasGroupTypeMixedIdOrName
  hasTemplatesFilterBySubject
}

# Column names for Query.emailNotifications.filter.
enum QueryEmailNotificationsFilterStaticType {
  company_id
  type
  recipient_type
  hasApplicantIndividualMixedIdOrFullname
  hasApplicantCompanyMixedIdOrName
  hasGroupRoleMixedIdOrName
  hasMemberMixedIdOrFullname
  hasGroupTypeMixedIdOrName
  hasTemplatesFilterBySubject
}

# Input column names for Query.emailNotifications.filter.
input QueryEmailNotificationsFilterStaticInput {
  company_id: ID
  type: NotifyType
  recipient_type: RecipientType
  hasApplicantIndividualMixedIdOrFullname: Mixed
  hasApplicantCompanyMixedIdOrName: Mixed
  hasGroupRoleMixedIdOrName: Mixed
  hasMemberMixedIdOrFullname: Mixed
  hasGroupTypeMixedIdOrName: Mixed
  hasTemplatesFilterBySubject: String
}

# Column names for Query.emailNotifications.filter.
enum QueryEmailNotificationsFilterStaticEnumNotifyType {
  ADMINISTRATION
  CLIENT
}

# Column names for Query.emailNotifications.filter.
enum QueryEmailNotificationsFilterStaticEnumRecipientType {
  PERSON
  GROUP
}

# Column names for Query.files.filter.
enum QueryFilesFilterStaticOperator {
  author_id
  entity_type
}

# Column names for Query.files.filter.
enum QueryFilesFilterStaticType {
  author_id
  entity_type
}

# Input column names for Query.files.filter.
input QueryFilesFilterStaticInput {
  author_id: ID
  entity_type: String
}

# Column names for Query.groups.filter.
enum QueryGroupsFilterStaticOperator {
  id
  company_id
  role_id
  name
  group_type_id
  is_active
}

# Column names for Query.groups.filter.
enum QueryGroupsFilterStaticType {
  id
  company_id
  role_id
  name
  group_type_id
  is_active
}

# Input column names for Query.groups.filter.
input QueryGroupsFilterStaticInput {
  id: ID
  company_id: ID
  role_id: ID
  name: String
  group_type_id: ID
  is_active: Boolean
}

# Column names for Query.groupList.filter.
enum QueryGroupListFilterStaticOperator {
  id
  company_id
  name
  role_id
  group_type_id
  is_active
  module_id
  commission_template_id
  payment_provider_id
}

# Column names for Query.groupList.filter.
enum QueryGroupListFilterStaticType {
  id
  company_id
  name
  role_id
  group_type_id
  is_active
  module_id
  commission_template_id
  payment_provider_id
}

# Input column names for Query.groupList.filter.
input QueryGroupListFilterStaticInput {
  id: ID
  company_id: ID
  name: String
  role_id: ID
  group_type_id: ID
  is_active: Boolean
  module_id: ID
  commission_template_id: ID
  payment_provider_id: ID
}

# Column names for Query.memberAccessLimitations.filter.
enum QueryMemberAccessLimitationsFilterStaticOperator {
  doesntHaveGroupRoles
  hasGroupRolesFilterById
  module_id
  project_id
  payment_provider_id
  group_type_id
}

# Column names for Query.memberAccessLimitations.filter.
enum QueryMemberAccessLimitationsFilterStaticType {
  doesntHaveGroupRoles
  hasGroupRolesFilterById
  module_id
  project_id
  payment_provider_id
  group_type_id
}

# Input column names for Query.memberAccessLimitations.filter.
input QueryMemberAccessLimitationsFilterStaticInput {
  doesntHaveGroupRoles: Boolean
  hasGroupRolesFilterById: ID
  module_id: ID
  project_id: ID
  payment_provider_id: ID
  group_type_id: ID
}

# Column names for Query.members.filter.
enum QueryMembersFilterStaticOperator {
  hasGroupRoleFilterById
  hasRoleFilterById
  id
  fullname
  company_id
  email
  department_position_id
  department_id
  last_login_at
  is_show_owner_applicants
  member_status_id
}

# Column names for Query.members.filter.
enum QueryMembersFilterStaticType {
  hasGroupRoleFilterById
  hasRoleFilterById
  id
  fullname
  company_id
  email
  department_position_id
  department_id
  last_login_at
  is_show_owner_applicants
  member_status_id
}

# Input column names for Query.members.filter.
input QueryMembersFilterStaticInput {
  hasGroupRoleFilterById: ID
  hasRoleFilterById: ID
  id: ID
  fullname: String
  company_id: ID
  email: String
  department_position_id: ID
  department_id: ID
  last_login_at: String
  is_show_owner_applicants: Boolean
  member_status_id: ID
}

# Column names for Query.paymentBanks.filter.
enum QueryPaymentBanksFilterStaticOperator {
  id
  country_id
  payment_system_id
  payment_provider_id
  name
  address
  bank_code
  payment_system_code
}

# Column names for Query.paymentBanks.filter.
enum QueryPaymentBanksFilterStaticType {
  id
  country_id
  payment_system_id
  payment_provider_id
  name
  address
  bank_code
  payment_system_code
}

# Input column names for Query.paymentBanks.filter.
input QueryPaymentBanksFilterStaticInput {
  id: ID
  country_id: ID
  payment_system_id: ID
  payment_provider_id: ID
  name: String
  address: String
  bank_code: String
  payment_system_code: String
}

# Column names for Query.paymentProviders.filter.
enum QueryPaymentProvidersFilterStaticOperator {
  name
  hasPaymentSystemsFilterById
  hasAccountFilterById
  hasCommissionTemplateFilterById
  company_id
  id
}

# Column names for Query.paymentProviders.filter.
enum QueryPaymentProvidersFilterStaticType {
  name
  hasPaymentSystemsFilterById
  hasAccountFilterById
  hasCommissionTemplateFilterById
  company_id
  id
}

# Input column names for Query.paymentProviders.filter.
input QueryPaymentProvidersFilterStaticInput {
  name: String
  hasPaymentSystemsFilterById: ID
  hasAccountFilterById: ID
  hasCommissionTemplateFilterById: ID
  company_id: ID
  id: ID
}

# Column names for Query.paymentProviderIbans.filter.
enum QueryPaymentProviderIbansFilterStaticOperator {
  name
  company_id
  currency_id
}

# Column names for Query.paymentProviderIbans.filter.
enum QueryPaymentProviderIbansFilterStaticType {
  name
  company_id
  currency_id
}

# Input column names for Query.paymentProviderIbans.filter.
input QueryPaymentProviderIbansFilterStaticInput {
  name: String
  company_id: ID
  currency_id: ID
}

# Column names for Query.paymentSystems.filter.
enum QueryPaymentSystemsFilterStaticOperator {
  id
  name
  hasProvidersFilterByName
  hasProvidersFilterById
  hasCompaniesFilterById
  hasRegionsFilterById
}

# Column names for Query.paymentSystems.filter.
enum QueryPaymentSystemsFilterStaticType {
  id
  name
  hasProvidersFilterByName
  hasProvidersFilterById
  hasCompaniesFilterById
  hasRegionsFilterById
}

# Input column names for Query.paymentSystems.filter.
input QueryPaymentSystemsFilterStaticInput {
  id: Mixed
  name: Mixed
  hasProvidersFilterByName: String
  hasProvidersFilterById: ID
  hasCompaniesFilterById: ID
  hasRegionsFilterById: ID
}

# Column names for Query.payments.filter.
enum QueryPaymentsFilterStaticOperator {
  id
  company_id
  payment_provider_id
  operation_type_id
  urgency_id
  status_id
  sender_name
  hasAccountFilterByAccountNumber
}

# Column names for Query.payments.filter.
enum QueryPaymentsFilterStaticType {
  id
  company_id
  payment_provider_id
  operation_type_id
  urgency_id
  status_id
  sender_name
  hasAccountFilterByAccountNumber
}

# Input column names for Query.payments.filter.
input QueryPaymentsFilterStaticInput {
  id: ID
  company_id: ID
  payment_provider_id: ID
  operation_type_id: ID
  urgency_id: ID
  status_id: ID
  sender_name: String
  hasAccountFilterByAccountNumber: String
}

# Column names for Query.projects.filter.
enum QueryProjectsFilterStaticOperator {
  id
  company_id
  module_id
}

# Column names for Query.projects.filter.
enum QueryProjectsFilterStaticType {
  id
  company_id
  module_id
}

# Input column names for Query.projects.filter.
input QueryProjectsFilterStaticInput {
  id: ID
  company_id: ID
  module_id: ID
}

# Column names for Query.regions.filter.
enum QueryRegionsFilterStaticOperator {
  company_id
  hasCountriesFilterById
  hasCountriesFilterByName
  hasPaymentSystemMixedIdOrName
}

# Column names for Query.regions.filter.
enum QueryRegionsFilterStaticType {
  company_id
  hasCountriesFilterById
  hasCountriesFilterByName
  hasPaymentSystemMixedIdOrName
}

# Input column names for Query.regions.filter.
input QueryRegionsFilterStaticInput {
  company_id: ID
  hasCountriesFilterById: ID
  hasCountriesFilterByName: String
  hasPaymentSystemMixedIdOrName: Mixed
}

# Column names for Query.roles.filter.
enum QueryRolesFilterStaticOperator {
  name
  company_id
  hasGroupTypeMixedIdOrName
  hasGroupsMixedIdOrName
}

# Column names for Query.roles.filter.
enum QueryRolesFilterStaticType {
  name
  company_id
  hasGroupTypeMixedIdOrName
  hasGroupsMixedIdOrName
}

# Input column names for Query.roles.filter.
input QueryRolesFilterStaticInput {
  name: String
  company_id: ID
  hasGroupTypeMixedIdOrName: Mixed
  hasGroupsMixedIdOrName: Mixed
}

# Column names for Query.tickets.filter.
enum QueryTicketsFilterStaticOperator {
  id
  member_id
  client_id
  hasCompanyFilterById
}

# Column names for Query.tickets.filter.
enum QueryTicketsFilterStaticType {
  id
  member_id
  client_id
  hasCompanyFilterById
}

# Input column names for Query.tickets.filter.
input QueryTicketsFilterStaticInput {
  id: ID
  member_id: ID
  client_id: ID
  hasCompanyFilterById: ID
}

# Column names for Query.transferIncomings.filter.
enum QueryTransferIncomingsFilterStaticOperator {
  id
  urgency_id
  operation_type_id
  sender_name
  status_id
  hasAccountFilterByAccountNumber
  hasFeeFilterByFee
  hasFeeFilterByFeeAmount
}

# Column names for Query.transferIncomings.filter.
enum QueryTransferIncomingsFilterStaticType {
  id
  urgency_id
  operation_type_id
  sender_name
  status_id
  hasAccountFilterByAccountNumber
  hasFeeFilterByFee
  hasFeeFilterByFeeAmount
}

# Input column names for Query.transferIncomings.filter.
input QueryTransferIncomingsFilterStaticInput {
  id: ID
  urgency_id: ID
  operation_type_id: ID
  sender_name: String
  status_id: ID
  hasAccountFilterByAccountNumber: String
  hasFeeFilterByFee: String
  hasFeeFilterByFeeAmount: String
}

# Column names for Query.transferOutgoings.filter.
enum QueryTransferOutgoingsFilterStaticOperator {
  id
  urgency_id
  operation_type_id
  status_id
  recipient_name
  user_type
  hasAccountFilterByAccountNumber
  hasSenderMixedNameOrFullname
  hasFeeFilterByFee
  hasFeeFilterByFeeAmount
}

# Column names for Query.transferOutgoings.filter.
enum QueryTransferOutgoingsFilterStaticType {
  id
  urgency_id
  operation_type_id
  status_id
  recipient_name
  user_type
  hasAccountFilterByAccountNumber
  hasSenderMixedNameOrFullname
  hasFeeFilterByFee
  hasFeeFilterByFeeAmount
}

# Input column names for Query.transferOutgoings.filter.
input QueryTransferOutgoingsFilterStaticInput {
  id: ID
  urgency_id: ID
  operation_type_id: ID
  status_id: ID
  recipient_name: String
  user_type: UserType
  hasAccountFilterByAccountNumber: String
  hasSenderMixedNameOrFullname: Mixed
  hasFeeFilterByFee: String
  hasFeeFilterByFeeAmount: String
}

# Column names for Query.transferOutgoings.filter.
enum QueryTransferOutgoingsFilterStaticEnumUserType {
  APPLICANT_INDIVIDUAL
  APPLICANT_COMPANY
  MEMBERS
}

# Column names for Query.users.filter.
enum QueryUsersFilterStaticOperator {
  id
  fullname
  company_id
  email
  group_id
  group_type_id
  role_id
}

# Column names for Query.users.filter.
enum QueryUsersFilterStaticType {
  id
  fullname
  company_id
  email
  group_id
  group_type_id
  role_id
}

# Input column names for Query.users.filter.
input QueryUsersFilterStaticInput {
  id: ID
  fullname: String
  company_id: ID
  email: String
  group_id: ID
  group_type_id: ID
  role_id: ID
}

# Information about pagination using a simple paginator.
type SimplePaginatorInfo {
  # Number of items in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the first item in the current page.
  firstItem: Int

  # Index of the last item in the current page.
  lastItem: Int

  # Number of items per page.
  perPage: Int!

  # Are there more pages after this one?
  hasMorePages: Boolean!
}

# Information about pagination using a Relay style cursor connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # The cursor to continue paginating backwards.
  startCursor: String

  # The cursor to continue paginating forwards.
  endCursor: String

  # Total number of nodes in the paginated connection.
  total: Int!

  # Number of nodes in the current page.
  count: Int!

  # Index of the current page.
  currentPage: Int!

  # Index of the last available page.
  lastPage: Int!
}

# Dynamic WHERE conditions for queries.
input WhereConditions {
  # The column that is used for the condition.
  column: String

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WhereConditions!]

  # Check whether a relation exists. Extra conditions or a minimum amount can be applied.
  HAS: WhereConditionsRelation
}

# Dynamic HAS conditions for WHERE condition queries.
input WhereConditionsRelation {
  # The relation that is checked.
  relation: String!

  # The comparison operator to test against the amount.
  operator: SQLOperator = GTE

  # The amount to test.
  amount: Int = 1

  # Additional condition logic.
  condition: WhereConditions
}

# Dynamic WHERE conditions for queries.
input FilterConditions {
  # The column that is used for the condition.
  column: String

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [FilterConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [FilterConditions!]
}

# Aggregate functions when ordering by a relation that may specify a column.
enum OrderByRelationWithColumnAggregateFunction {
  # Average.
  AVG

  # Minimum.
  MIN

  # Maximum.
  MAX

  # Sum.
  SUM

  # Amount of items.
  COUNT
}

# Allows ordering a list of records.
input OrderByClause {
  # The column that is used for ordering.
  column: String!

  # The direction that is used for ordering.
  order: SortOrder!
}

# PermissionType
type PermissionType {
  PERMISSION_TICKETS: PERMISSION_TICKETS
  PERMISSION_DASHBOARD: PERMISSION_DASHBOARD
  PERMISSION_MY_NET_WORTH: PERMISSION_MY_NET_WORTH
  PERMISSION_ACCOUNT_DETAILS: PERMISSION_ACCOUNT_DETAILS
  PERMISSION_MAKE_PAYMENTS: PERMISSION_MAKE_PAYMENTS
  PERMISSION_REQUISITES: PERMISSION_REQUISITES
  PERMISSION_MY_TEMPLATES: PERMISSION_MY_TEMPLATES
  PERMISSION_STATEMENTS: PERMISSION_STATEMENTS
  PERMISSION_PAYMENT_LIST: PERMISSION_PAYMENT_LIST
  PERMISSION_PAYMENT_DETAILS: PERMISSION_PAYMENT_DETAILS
  PERMISSION_SETTINGS_CONTACT_DETAILS: PERMISSION_SETTINGS_CONTACT_DETAILS
  PERMISSION_SETTINGS_LOG_IN_DETAILS: PERMISSION_SETTINGS_LOG_IN_DETAILS
  PERMISSION_SETTINGS_SECURITY_LEVEL: PERMISSION_SETTINGS_SECURITY_LEVEL
  PERMISSION_SETTINGS_ACCOUNT: PERMISSION_SETTINGS_ACCOUNT
}
